-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj3\hdlsrc\gaussianFilter\gaussianF_ip_src_row2_linebuffer.vhd
-- Created: 2024-06-04 12:27:50
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: gaussianF_ip_src_row2_linebuffer
-- Source Path: NeighborhoodCreator_3x3/row2_linebuffer
-- Hierarchy Level: 4
-- Model version: 8.37
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY gaussianF_ip_src_row2_linebuffer IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        sample_in                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        onEndVals_in                      :   IN    std_logic;
        valid                             :   IN    std_logic;
        isLastSample                      :   IN    std_logic;
        sample                            :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        onEndVals                         :   OUT   std_logic
        );
END gaussianF_ip_src_row2_linebuffer;


ARCHITECTURE rtl OF gaussianF_ip_src_row2_linebuffer IS

  -- Component Declarations
  COMPONENT gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout                            :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : gaussianF_ip_src_SimpleDualPortRAM_generic
    USE ENTITY work.gaussianF_ip_src_SimpleDualPortRAM_generic(rtl);

  -- Signals
  SIGNAL wrEn_1                           : std_logic;
  SIGNAL endValsLoad_1                    : std_logic;
  SIGNAL endValsCount_loadValue_1         : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL onEndVals_1                      : std_logic;
  SIGNAL endValsCount_1                   : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL rdEn_1                           : std_logic;
  SIGNAL enb_2                            : std_logic;
  SIGNAL wrAddr_1                         : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL rdAddrLoad_1                     : std_logic;
  SIGNAL wrAddrIsMax_1                    : std_logic;
  SIGNAL one_1                            : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL wrAddrPlusOne_1                  : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL zero_1                           : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL wrAddrIncr_1                     : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL wrAddrNext_1                     : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL rdAddr_1                         : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL ram                              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL sample_1                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL sample_hold_1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32

BEGIN
  u_ram_generic : gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 10,
                 DataWidth => 32
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => sample_in,
              wr_addr => std_logic_vector(wrAddr_1),
              wr_en => wrEn_1,
              rd_addr => std_logic_vector(rdAddr_1),
              dout => ram
              );

  wrEn_1 <= valid OR onEndVals_in;

  endValsLoad_1 <= onEndVals_in OR isLastSample;

  endValsCount_loadValue_1 <= to_unsigned(16#001#, 10);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 750
  endValsCount_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        endValsCount_1 <= to_unsigned(16#000#, 10);
      ELSIF enb = '1' THEN
        IF endValsLoad_1 = '1' THEN 
          endValsCount_1 <= endValsCount_loadValue_1;
        ELSIF onEndVals_1 = '1' THEN 
          IF endValsCount_1 >= to_unsigned(16#2EE#, 10) THEN 
            endValsCount_1 <= to_unsigned(16#000#, 10);
          ELSE 
            endValsCount_1 <= endValsCount_1 + to_unsigned(16#001#, 10);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS endValsCount_process;


  
  onEndVals_1 <= '1' WHEN endValsCount_1 /= to_unsigned(16#000#, 10) ELSE
      '0';

  rdEn_1 <= wrEn_1 OR onEndVals_1;

  enb_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        enb_2 <= '0';
      ELSIF enb = '1' THEN
        enb_2 <= rdEn_1;
      END IF;
    END IF;
  END PROCESS enb_1_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 748
  wrAddr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        wrAddr_1 <= to_unsigned(16#000#, 10);
      ELSIF enb = '1' THEN
        IF wrEn_1 = '1' THEN 
          IF wrAddr_1 >= to_unsigned(16#2EC#, 10) THEN 
            wrAddr_1 <= to_unsigned(16#000#, 10);
          ELSE 
            wrAddr_1 <= wrAddr_1 + to_unsigned(16#001#, 10);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS wrAddr_process;


  
  rdAddrLoad_1 <= '1' WHEN endValsCount_1 = to_unsigned(16#2EE#, 10) ELSE
      '0';

  
  wrAddrIsMax_1 <= '1' WHEN wrAddr_1 = to_unsigned(16#2EC#, 10) ELSE
      '0';

  one_1 <= to_unsigned(16#001#, 10);

  wrAddrPlusOne_1 <= wrAddr_1 + one_1;

  zero_1 <= to_unsigned(16#000#, 10);

  
  wrAddrIncr_1 <= wrAddrPlusOne_1 WHEN wrAddrIsMax_1 = '0' ELSE
      zero_1;

  
  wrAddrNext_1 <= wrAddr_1 WHEN wrEn_1 = '0' ELSE
      wrAddrIncr_1;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 748
  rdAddr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        rdAddr_1 <= to_unsigned(16#000#, 10);
      ELSIF enb = '1' THEN
        IF rdAddrLoad_1 = '1' THEN 
          rdAddr_1 <= wrAddrNext_1;
        ELSIF rdEn_1 = '1' THEN 
          IF rdAddr_1 >= to_unsigned(16#2EC#, 10) THEN 
            rdAddr_1 <= to_unsigned(16#000#, 10);
          ELSE 
            rdAddr_1 <= rdAddr_1 + to_unsigned(16#001#, 10);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS rdAddr_process;


  sample_hold_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        sample_hold_1 <= X"00000000";
      ELSIF enb = '1' THEN
        sample_hold_1 <= sample_1;
      END IF;
    END IF;
  END PROCESS sample_hold_process;


  
  sample_1 <= sample_hold_1 WHEN enb_2 = '0' ELSE
      ram;

  sample <= sample_1;

  onEndVals <= onEndVals_1;

END rtl;

