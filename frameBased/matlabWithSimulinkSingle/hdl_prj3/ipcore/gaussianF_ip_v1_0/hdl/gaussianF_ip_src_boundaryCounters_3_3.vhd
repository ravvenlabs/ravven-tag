-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj3\hdlsrc\gaussianFilter\gaussianF_ip_src_boundaryCounters_3_3.vhd
-- Created: 2024-06-04 12:27:50
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: gaussianF_ip_src_boundaryCounters_3_3
-- Source Path: boundaryCounters_3_3
-- Hierarchy Level: 3
-- Model version: 8.37
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY gaussianF_ip_src_boundaryCounters_3_3 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        validNext                         :   IN    std_logic;
        valid                             :   IN    std_logic;
        isLastSample                      :   IN    std_logic;
        isEndOfLine                       :   IN    std_logic;
        rowCtr                            :   IN    std_logic_vector(8 DOWNTO 0);  -- ufix9
        colCtr                            :   IN    std_logic_vector(9 DOWNTO 0);  -- ufix10
        pxlCtr                            :   IN    std_logic_vector(18 DOWNTO 0);  -- ufix19
        isEndOfLineEnd                    :   IN    std_logic;
        rowCtrEnd                         :   IN    std_logic_vector(8 DOWNTO 0);  -- ufix9
        colCtrEnd                         :   IN    std_logic_vector(9 DOWNTO 0);  -- ufix10
        pxlCtrEnd                         :   IN    std_logic_vector(18 DOWNTO 0);  -- ufix19
        rowCtr_3_3                        :   OUT   std_logic_vector(8 DOWNTO 0);  -- ufix9
        colCtr_3_3                        :   OUT   std_logic_vector(9 DOWNTO 0);  -- ufix10
        shift_3_3                         :   OUT   std_logic;  -- ufix1
        valid_3_3                         :   OUT   std_logic
        );
END gaussianF_ip_src_boundaryCounters_3_3;


ARCHITECTURE rtl OF gaussianF_ip_src_boundaryCounters_3_3 IS

  -- Signals
  SIGNAL pxlCtrEnd_unsigned               : unsigned(18 DOWNTO 0);  -- ufix19
  SIGNAL endCtrNonzero_1                  : std_logic;
  SIGNAL endCtrInBounds_1                 : std_logic;
  SIGNAL onEndValues_1                    : std_logic;
  SIGNAL isEOL_1                          : std_logic;
  SIGNAL onEOL                            : std_logic;
  SIGNAL shiftEnb_1                       : std_logic;
  SIGNAL shiftCtr_1                       : std_logic;  -- ufix1
  SIGNAL notOnEOL_1                       : std_logic;
  SIGNAL rowCtr_unsigned                  : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL rowCtrEnd_unsigned               : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL rowCtrToUse_1                    : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL rowCtr_3_3_tmp                   : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL rowCtr_3_3_hold_1                : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL colCtr_unsigned                  : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL colCtrEnd_unsigned               : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL colCtrToUse_1                    : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL colCtrEOL_1                      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL colCtr_3_3_tmp                   : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL pxlCtr_unsigned                  : unsigned(18 DOWNTO 0);  -- ufix19
  SIGNAL pxlCtrInBounds_1                 : std_logic;
  SIGNAL isValid_1                        : std_logic;
  SIGNAL lastPxlWasEOL                    : std_logic;
  SIGNAL lastPxlWasEOL_hold_1             : std_logic;
  SIGNAL isValidNext_1                    : std_logic;
  SIGNAL onNextLine                       : std_logic;
  SIGNAL onNextLineNext_1                 : std_logic;
  SIGNAL nextLineEnb_1                    : std_logic;
  SIGNAL nextLineCtr_1                    : std_logic;  -- ufix1
  SIGNAL notNextLine_1                    : std_logic;
  SIGNAL currSampleValid_1                : std_logic;
  SIGNAL validInFrame_1                   : std_logic;
  SIGNAL validCurrFrame_1                 : std_logic;
  SIGNAL validOut_1                       : std_logic;

BEGIN
  pxlCtrEnd_unsigned <= unsigned(pxlCtrEnd);

  
  endCtrNonzero_1 <= '1' WHEN pxlCtrEnd_unsigned > to_unsigned(16#00000#, 19) ELSE
      '0';

  
  endCtrInBounds_1 <= '1' WHEN pxlCtrEnd_unsigned < to_unsigned(16#002F2#, 19) ELSE
      '0';

  onEndValues_1 <= endCtrNonzero_1 AND endCtrInBounds_1;

  
  isEOL_1 <= isEndOfLine WHEN onEndValues_1 = '0' ELSE
      isEndOfLineEnd;

  shiftEnb_1 <= onEOL OR isEOL_1;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  shiftCtr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        shiftCtr_1 <= '0';
      ELSIF enb = '1' AND shiftEnb_1 = '1' THEN
        shiftCtr_1 <=  NOT shiftCtr_1;
      END IF;
    END IF;
  END PROCESS shiftCtr_process;


  onEOL <= shiftCtr_1;

  notOnEOL_1 <=  NOT onEOL;

  rowCtr_unsigned <= unsigned(rowCtr);

  rowCtrEnd_unsigned <= unsigned(rowCtrEnd);

  
  rowCtrToUse_1 <= rowCtr_unsigned WHEN onEndValues_1 = '0' ELSE
      rowCtrEnd_unsigned;

  rowCtr_3_3_hold_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        rowCtr_3_3_hold_1 <= to_unsigned(16#000#, 9);
      ELSIF enb = '1' THEN
        rowCtr_3_3_hold_1 <= rowCtr_3_3_tmp;
      END IF;
    END IF;
  END PROCESS rowCtr_3_3_hold_process;


  
  rowCtr_3_3_tmp <= rowCtr_3_3_hold_1 WHEN notOnEOL_1 = '0' ELSE
      rowCtrToUse_1;

  rowCtr_3_3 <= std_logic_vector(rowCtr_3_3_tmp);

  colCtr_unsigned <= unsigned(colCtr);

  colCtrEnd_unsigned <= unsigned(colCtrEnd);

  
  colCtrToUse_1 <= colCtr_unsigned WHEN onEndValues_1 = '0' ELSE
      colCtrEnd_unsigned;

  colCtrEOL_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & shiftCtr_1;

  
  colCtr_3_3_tmp <= colCtrToUse_1 WHEN onEOL = '0' ELSE
      colCtrEOL_1;

  colCtr_3_3 <= std_logic_vector(colCtr_3_3_tmp);

  shift_3_3 <= shiftCtr_1;

  pxlCtr_unsigned <= unsigned(pxlCtr);

  
  pxlCtrInBounds_1 <= '1' WHEN pxlCtr_unsigned > to_unsigned(16#002F1#, 19) ELSE
      '0';

  isValid_1 <= onEndValues_1 OR valid;

  lastPxlWasEOL_hold_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        lastPxlWasEOL_hold_1 <= '0';
      ELSIF enb = '1' THEN
        lastPxlWasEOL_hold_1 <= lastPxlWasEOL;
      END IF;
    END IF;
  END PROCESS lastPxlWasEOL_hold_process;


  
  lastPxlWasEOL <= lastPxlWasEOL_hold_1 WHEN isValid_1 = '0' ELSE
      isEOL_1;

  isValidNext_1 <= isLastSample OR (onEndValues_1 OR validNext);

  onNextLineNext_1 <= lastPxlWasEOL OR onNextLine;

  nextLineEnb_1 <= onNextLineNext_1 AND isValidNext_1;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  nextLineCtr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        nextLineCtr_1 <= '0';
      ELSIF enb = '1' AND nextLineEnb_1 = '1' THEN
        nextLineCtr_1 <=  NOT nextLineCtr_1;
      END IF;
    END IF;
  END PROCESS nextLineCtr_process;


  onNextLine <= nextLineCtr_1;

  notNextLine_1 <=  NOT onNextLine;

  currSampleValid_1 <= valid AND notNextLine_1;

  validInFrame_1 <= currSampleValid_1 OR onEOL;

  validCurrFrame_1 <= pxlCtrInBounds_1 AND validInFrame_1;

  validOut_1 <= validCurrFrame_1 OR onEndValues_1;

  valid_3_3 <= validOut_1;

END rtl;

