-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj1\hdlsrc\gaussianFilter\gaussianF_ip_src_enabledDelayMatch.vhd
-- Created: 2024-06-04 12:57:05
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: gaussianF_ip_src_enabledDelayMatch
-- Source Path: gaussianFilter/gaussianFilter/frameBasedGaussianFilter/enabledDelayMatch
-- Hierarchy Level: 2
-- Model version: 8.37
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.gaussianF_ip_src_gaussianFilter_pkg.ALL;

ENTITY gaussianF_ip_src_enabledDelayMatch IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        data_0                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_1                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_2                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_3                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_4                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_5                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_6                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_7                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_8                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        ImageIn_valid                     :   IN    std_logic;
        in_neighborhood_valid             :   IN    std_logic;
        data1_0                           :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        data1_1                           :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        data1_2                           :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        data1_3                           :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        data1_4                           :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        data1_5                           :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        data1_6                           :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        data1_7                           :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        data1_8                           :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
        );
END gaussianF_ip_src_enabledDelayMatch;


ARCHITECTURE rtl OF gaussianF_ip_src_enabledDelayMatch IS

  -- Signals
  SIGNAL frameReadCtr_1                   : unsigned(18 DOWNTO 0);  -- ufix19
  SIGNAL firstReadSample_1                : std_logic;
  SIGNAL enbFinalDelay_1                  : std_logic;
  SIGNAL frameWriteCtr_1                  : unsigned(18 DOWNTO 0);  -- ufix19
  SIGNAL firstWrittenSample_1             : std_logic;
  SIGNAL enbInitialDelay_1                : std_logic;
  SIGNAL data                             : matrix_of_std_logic_vector32(0 TO 2, 0 TO 2);  -- ufix32 [3x3]
  SIGNAL c6_data                          : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL c7_data_next                     : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL c6_data_hold                     : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL c7_data_next_1                   : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL data_out                         : matrix_of_std_logic_vector32(0 TO 2, 0 TO 2);  -- ufix32 [3x3]
  SIGNAL c8_data_out                      : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL c8_data_out_hold                 : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL c9_data_out                      : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]

BEGIN
  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 360960
  frameReadCtr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        frameReadCtr_1 <= to_unsigned(16#00001#, 19);
      ELSIF enb = '1' THEN
        IF in_neighborhood_valid = '1' THEN 
          IF frameReadCtr_1 >= to_unsigned(16#58200#, 19) THEN 
            frameReadCtr_1 <= to_unsigned(16#00001#, 19);
          ELSE 
            frameReadCtr_1 <= frameReadCtr_1 + to_unsigned(16#00001#, 19);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS frameReadCtr_process;


  
  firstReadSample_1 <= '1' WHEN frameReadCtr_1 = to_unsigned(16#00001#, 19) ELSE
      '0';

  enbFinalDelay_1 <= firstReadSample_1 AND in_neighborhood_valid;

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 360960
  frameWriteCtr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        frameWriteCtr_1 <= to_unsigned(16#00001#, 19);
      ELSIF enb = '1' THEN
        IF ImageIn_valid = '1' THEN 
          IF frameWriteCtr_1 >= to_unsigned(16#58200#, 19) THEN 
            frameWriteCtr_1 <= to_unsigned(16#00001#, 19);
          ELSE 
            frameWriteCtr_1 <= frameWriteCtr_1 + to_unsigned(16#00001#, 19);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS frameWriteCtr_process;


  
  firstWrittenSample_1 <= '1' WHEN frameWriteCtr_1 = to_unsigned(16#00001#, 19) ELSE
      '0';

  enbInitialDelay_1 <= firstWrittenSample_1 AND ImageIn_valid;

  data(0, 0) <= data_0;
  data(1, 0) <= data_1;
  data(2, 0) <= data_2;
  data(0, 1) <= data_3;
  data(1, 1) <= data_4;
  data(2, 1) <= data_5;
  data(0, 2) <= data_6;
  data(1, 2) <= data_7;
  data(2, 2) <= data_8;

  c6_data_gen1: FOR d1 IN 0 TO 2 GENERATE
    c6_data_gen: FOR d0 IN 0 TO 2 GENERATE
      c6_data(d0 + (d1 * 3)) <= data(d0, d1);
    END GENERATE;
  END GENERATE;

  
  c6_data_hold <= c7_data_next WHEN enbInitialDelay_1 = '0' ELSE
      c6_data;

  data_next_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        c7_data_next <= (OTHERS => X"00000000");
      ELSIF enb = '1' THEN
        c7_data_next <= c6_data_hold;
      END IF;
    END IF;
  END PROCESS data_next_process;


  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        c7_data_next_1 <= (OTHERS => X"00000000");
      ELSIF enb = '1' THEN
        c7_data_next_1 <= c7_data_next;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  c8_data_out_gen1: FOR d1 IN 0 TO 2 GENERATE
    c8_data_out_gen: FOR d0 IN 0 TO 2 GENERATE
      c8_data_out(d0 + (d1 * 3)) <= data_out(d0, d1);
    END GENERATE;
  END GENERATE;

  data_out_hold_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        c8_data_out_hold <= (OTHERS => X"00000000");
      ELSIF enb = '1' THEN
        c8_data_out_hold <= c8_data_out;
      END IF;
    END IF;
  END PROCESS data_out_hold_process;


  
  c9_data_out <= c8_data_out_hold WHEN enbFinalDelay_1 = '0' ELSE
      c7_data_next_1;

  data_out_gen1: FOR d1 IN 0 TO 2 GENERATE
    data_out_gen: FOR d0 IN 0 TO 2 GENERATE
      data_out(d0, d1) <= c9_data_out(d0 + (d1 * 3));
    END GENERATE;
  END GENERATE;

  data1_0 <= data_out(0, 0);

  data1_1 <= data_out(1, 0);

  data1_2 <= data_out(2, 0);

  data1_3 <= data_out(0, 1);

  data1_4 <= data_out(1, 1);

  data1_5 <= data_out(2, 1);

  data1_6 <= data_out(0, 2);

  data1_7 <= data_out(1, 2);

  data1_8 <= data_out(2, 2);

END rtl;

