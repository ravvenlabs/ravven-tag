-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj1\hdlsrc\gaussianFilter\gaussianF_ip_src_singleToUint32.vhd
-- Created: 2024-06-04 12:57:05
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: gaussianF_ip_src_singleToUint32
-- Source Path: gaussianFilter/gaussianFilter/singleToUint32
-- Hierarchy Level: 1
-- Model version: 8.37
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY gaussianF_ip_src_singleToUint32 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        In1                               :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        In1_valid                         :   IN    std_logic;
        u                                 :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        u_valid                           :   OUT   std_logic
        );
END gaussianF_ip_src_singleToUint32;


ARCHITECTURE rtl OF gaussianF_ip_src_singleToUint32 IS

  -- Component Declarations
  COMPONENT gaussianF_ip_src_nfp_convert_single_to_sfix_64_En0
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in                          :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(63 DOWNTO 0)  -- sfix64
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_abs_single
    PORT( nfp_in                          :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_log_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in                          :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_div_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_add_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_convert_single_to_fix_8_En0
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in                          :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout                            :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_convert_single_to_sfix_8_En0
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in                          :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(7 DOWNTO 0)  -- int8
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_convert_sfix_8_En0_to_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in                          :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_pow_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_recip_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in                          :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_mul_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_sub_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_convert_single_to_sfix_24_En23
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in                          :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(23 DOWNTO 0)  -- sfix24_En23
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : gaussianF_ip_src_nfp_convert_single_to_sfix_64_En0
    USE ENTITY work.gaussianF_ip_src_nfp_convert_single_to_sfix_64_En0(rtl);

  FOR ALL : gaussianF_ip_src_nfp_abs_single
    USE ENTITY work.gaussianF_ip_src_nfp_abs_single(rtl);

  FOR ALL : gaussianF_ip_src_nfp_log_single
    USE ENTITY work.gaussianF_ip_src_nfp_log_single(rtl);

  FOR ALL : gaussianF_ip_src_nfp_div_single
    USE ENTITY work.gaussianF_ip_src_nfp_div_single(rtl);

  FOR ALL : gaussianF_ip_src_nfp_add_single
    USE ENTITY work.gaussianF_ip_src_nfp_add_single(rtl);

  FOR ALL : gaussianF_ip_src_nfp_convert_single_to_fix_8_En0
    USE ENTITY work.gaussianF_ip_src_nfp_convert_single_to_fix_8_En0(rtl);

  FOR ALL : gaussianF_ip_src_SimpleDualPortRAM_generic
    USE ENTITY work.gaussianF_ip_src_SimpleDualPortRAM_generic(rtl);

  FOR ALL : gaussianF_ip_src_nfp_convert_single_to_sfix_8_En0
    USE ENTITY work.gaussianF_ip_src_nfp_convert_single_to_sfix_8_En0(rtl);

  FOR ALL : gaussianF_ip_src_nfp_convert_sfix_8_En0_to_single
    USE ENTITY work.gaussianF_ip_src_nfp_convert_sfix_8_En0_to_single(rtl);

  FOR ALL : gaussianF_ip_src_nfp_pow_single
    USE ENTITY work.gaussianF_ip_src_nfp_pow_single(rtl);

  FOR ALL : gaussianF_ip_src_nfp_recip_single
    USE ENTITY work.gaussianF_ip_src_nfp_recip_single(rtl);

  FOR ALL : gaussianF_ip_src_nfp_mul_single
    USE ENTITY work.gaussianF_ip_src_nfp_mul_single(rtl);

  FOR ALL : gaussianF_ip_src_nfp_sub_single
    USE ENTITY work.gaussianF_ip_src_nfp_sub_single(rtl);

  FOR ALL : gaussianF_ip_src_nfp_convert_single_to_sfix_24_En23
    USE ENTITY work.gaussianF_ip_src_nfp_convert_single_to_sfix_24_En23(rtl);

  -- Signals
  SIGNAL Data_Type_Conversion1_out1       : std_logic_vector(63 DOWNTO 0);  -- ufix64
  SIGNAL Data_Type_Conversion1_out1_signed : signed(63 DOWNTO 0);  -- sfix64
  SIGNAL Bit_Slice_out1                   : std_logic;  -- ufix1
  SIGNAL delayMatch1_reg                  : std_logic_vector(109 DOWNTO 0);  -- ufix1 [110]
  SIGNAL Bit_Slice_out1_1                 : std_logic;  -- ufix1
  SIGNAL Abs_out1                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Log_out1                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Log1_out1                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Divide_out1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Bias_const_val_1                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Bias_out1                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Data_Type_Conversion_out1        : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL Data_Type_Conversion_out1_unsigned : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL delayMatch2_regin                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL delayMatch2_waddr                : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL delayMatch2_wrenb                : std_logic;  -- ufix1
  SIGNAL delayMatch2_raddr                : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL delayMatch2_regout               : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL delayMatch2_regout_unsigned      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Abs1_out1                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL delayMatch_regin                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL delayMatch_waddr                 : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL delayMatch_wrenb                 : std_logic;  -- ufix1
  SIGNAL delayMatch_raddr                 : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL delayMatch_regout                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Abs1_out1_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Constant4_out1                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Data_Type_Conversion2_out1       : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL Data_Type_Conversion3_out1       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Math_Function1_out1              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Divide1_recip_out                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Divide1_out1                     : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Constant2_out1                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Sum_out1                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Data_Type_Conversion_out1_1      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Data_Type_Conversion5_out1       : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL Data_Type_Conversion5_out1_signed : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Data_Type_Conversion5_out1_1     : unsigned(22 DOWNTO 0);  -- ufix23_En23
  SIGNAL y                                : unsigned(31 DOWNTO 0);  -- uint32

BEGIN
  u_gaussianFilter_gaussianFilter_singleToUint32_nfp_convert_single_to_sfix_64_En0 : gaussianF_ip_src_nfp_convert_single_to_sfix_64_En0
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in => In1,  -- single
              nfp_out => Data_Type_Conversion1_out1  -- sfix64
              );

  u_nfp_abs_comp : gaussianF_ip_src_nfp_abs_single
    PORT MAP( nfp_in => In1,  -- single
              nfp_out => Abs_out1  -- single
              );

  u_nfp_log_comp : gaussianF_ip_src_nfp_log_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in => Abs_out1,  -- single
              nfp_out => Log_out1  -- single
              );

  u_nfp_div_comp : gaussianF_ip_src_nfp_div_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => Log_out1,  -- single
              nfp_in2 => Log1_out1,  -- single
              nfp_out => Divide_out1  -- single
              );

  u_nfp_add_comp : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => Divide_out1,  -- single
              nfp_in2 => Bias_const_val_1,  -- single
              nfp_out => Bias_out1  -- single
              );

  u_gaussianFilter_gaussianFilter_singleToUint32_nfp_convert_single_to_fix_8_En0 : gaussianF_ip_src_nfp_convert_single_to_fix_8_En0
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in => Bias_out1,  -- single
              nfp_out => Data_Type_Conversion_out1  -- uint8
              );

  u_ShiftRegisterRAM : gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 7,
                 DataWidth => 8
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(delayMatch2_regin),
              wr_addr => std_logic_vector(delayMatch2_waddr),
              wr_en => delayMatch2_wrenb,  -- ufix1
              rd_addr => std_logic_vector(delayMatch2_raddr),
              dout => delayMatch2_regout
              );

  u_nfp_abs_comp_1 : gaussianF_ip_src_nfp_abs_single
    PORT MAP( nfp_in => In1,  -- single
              nfp_out => Abs1_out1  -- single
              );

  u_ShiftRegisterRAM_1 : gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 7,
                 DataWidth => 32
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => delayMatch_regin,
              wr_addr => std_logic_vector(delayMatch_waddr),
              wr_en => delayMatch_wrenb,  -- ufix1
              rd_addr => std_logic_vector(delayMatch_raddr),
              dout => delayMatch_regout
              );

  u_gaussianFilter_gaussianFilter_singleToUint32_nfp_convert_single_to_sfix_8_En0 : gaussianF_ip_src_nfp_convert_single_to_sfix_8_En0
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in => Divide_out1,  -- single
              nfp_out => Data_Type_Conversion2_out1  -- int8
              );

  u_gaussianFilter_gaussianFilter_singleToUint32_nfp_convert_sfix_8_En0_to_single : gaussianF_ip_src_nfp_convert_sfix_8_En0_to_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in => Data_Type_Conversion2_out1,  -- int8
              nfp_out => Data_Type_Conversion3_out1  -- single
              );

  u_nfp_pow_comp : gaussianF_ip_src_nfp_pow_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => Constant4_out1,  -- single
              nfp_in2 => Data_Type_Conversion3_out1,  -- single
              nfp_out => Math_Function1_out1  -- single
              );

  u_nfp_recip_comp : gaussianF_ip_src_nfp_recip_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in => Math_Function1_out1,  -- single
              nfp_out => Divide1_recip_out  -- single
              );

  u_nfp_mul_comp : gaussianF_ip_src_nfp_mul_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => Abs1_out1_1,  -- single
              nfp_in2 => Divide1_recip_out,  -- single
              nfp_out => Divide1_out1  -- single
              );

  u_nfp_sub_comp : gaussianF_ip_src_nfp_sub_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => Divide1_out1,  -- single
              nfp_in2 => Constant2_out1,  -- single
              nfp_out => Sum_out1  -- single
              );

  u_gaussianFilter_gaussianFilter_singleToUint32_nfp_convert_single_to_sfix_24_En23 : gaussianF_ip_src_nfp_convert_single_to_sfix_24_En23
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in => Sum_out1,  -- single
              nfp_out => Data_Type_Conversion5_out1  -- sfix24_En23
              );

  Data_Type_Conversion1_out1_signed <= signed(Data_Type_Conversion1_out1);

  Bit_Slice_out1 <= Data_Type_Conversion1_out1_signed(63);

  delayMatch1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch1_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch1_reg(0) <= Bit_Slice_out1;
        delayMatch1_reg(109 DOWNTO 1) <= delayMatch1_reg(108 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS delayMatch1_process;

  Bit_Slice_out1_1 <= delayMatch1_reg(109);

  Log1_out1 <= X"3f317218";

  Bias_const_val_1 <= X"42fe0000";

  Data_Type_Conversion_out1_unsigned <= unsigned(Data_Type_Conversion_out1);

  -- Input register for RAM-based shift register delayMatch2
  delayMatch2_reginc_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch2_regin <= to_unsigned(16#00#, 8);
      ELSIF enb = '1' THEN
        delayMatch2_regin <= Data_Type_Conversion_out1_unsigned;
      END IF;
    END IF;
  END PROCESS delayMatch2_reginc_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 64
  -- Write address counter for RAM-based shift register delayMatch2
  delayMatch2_wr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch2_waddr <= to_unsigned(16#00#, 7);
      ELSIF enb = '1' THEN
        IF delayMatch2_waddr >= to_unsigned(16#40#, 7) THEN 
          delayMatch2_waddr <= to_unsigned(16#00#, 7);
        ELSE 
          delayMatch2_waddr <= delayMatch2_waddr + to_unsigned(16#01#, 7);
        END IF;
      END IF;
    END IF;
  END PROCESS delayMatch2_wr_process;


  delayMatch2_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 64
  -- Read address counter for RAM-based shift register delayMatch2
  delayMatch2_rd_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch2_raddr <= to_unsigned(16#01#, 7);
      ELSIF enb = '1' THEN
        IF delayMatch2_raddr >= to_unsigned(16#40#, 7) THEN 
          delayMatch2_raddr <= to_unsigned(16#00#, 7);
        ELSE 
          delayMatch2_raddr <= delayMatch2_raddr + to_unsigned(16#01#, 7);
        END IF;
      END IF;
    END IF;
  END PROCESS delayMatch2_rd_process;


  delayMatch2_regout_unsigned <= unsigned(delayMatch2_regout);

  -- Input register for RAM-based shift register delayMatch
  delayMatch_reginc_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch_regin <= X"00000000";
      ELSIF enb = '1' THEN
        delayMatch_regin <= Abs1_out1;
      END IF;
    END IF;
  END PROCESS delayMatch_reginc_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 95
  -- Write address counter for RAM-based shift register delayMatch
  delayMatch_wr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch_waddr <= to_unsigned(16#00#, 7);
      ELSIF enb = '1' THEN
        IF delayMatch_waddr >= to_unsigned(16#5F#, 7) THEN 
          delayMatch_waddr <= to_unsigned(16#00#, 7);
        ELSE 
          delayMatch_waddr <= delayMatch_waddr + to_unsigned(16#01#, 7);
        END IF;
      END IF;
    END IF;
  END PROCESS delayMatch_wr_process;


  delayMatch_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 95
  -- Read address counter for RAM-based shift register delayMatch
  delayMatch_rd_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch_raddr <= to_unsigned(16#01#, 7);
      ELSIF enb = '1' THEN
        IF delayMatch_raddr >= to_unsigned(16#5F#, 7) THEN 
          delayMatch_raddr <= to_unsigned(16#00#, 7);
        ELSE 
          delayMatch_raddr <= delayMatch_raddr + to_unsigned(16#01#, 7);
        END IF;
      END IF;
    END IF;
  END PROCESS delayMatch_rd_process;


  -- Output register for RAM-based shift register delayMatch
  delayMatch_regoutc_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Abs1_out1_1 <= X"00000000";
      ELSIF enb = '1' THEN
        Abs1_out1_1 <= delayMatch_regout;
      END IF;
    END IF;
  END PROCESS delayMatch_regoutc_process;


  Constant4_out1 <= X"40000000";

  Constant2_out1 <= X"3f800000";

  -- Output register for RAM-based shift register delayMatch2
  delayMatch2_regoutc_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Data_Type_Conversion_out1_1 <= to_unsigned(16#00#, 8);
      ELSIF enb = '1' THEN
        Data_Type_Conversion_out1_1 <= delayMatch2_regout_unsigned;
      END IF;
    END IF;
  END PROCESS delayMatch2_regoutc_process;


  Data_Type_Conversion5_out1_signed <= signed(Data_Type_Conversion5_out1);

  Data_Type_Conversion5_out1_1 <= unsigned(Data_Type_Conversion5_out1_signed(22 DOWNTO 0));

  y <= Bit_Slice_out1_1 & Data_Type_Conversion_out1_1 & Data_Type_Conversion5_out1_1;

  u <= std_logic_vector(y);

  u_valid <= In1_valid;

END rtl;

