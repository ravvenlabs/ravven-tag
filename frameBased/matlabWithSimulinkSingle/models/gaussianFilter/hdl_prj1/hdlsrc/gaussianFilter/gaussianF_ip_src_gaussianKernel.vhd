-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj1\hdlsrc\gaussianFilter\gaussianF_ip_src_gaussianKernel.vhd
-- Created: 2024-06-04 12:57:05
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: gaussianF_ip_src_gaussianKernel
-- Source Path: gaussianFilter/gaussianFilter/frameBasedGaussianFilter/gaussianKernel
-- Hierarchy Level: 2
-- Model version: 8.37
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.gaussianF_ip_src_gaussianFilter_pkg.ALL;

ENTITY gaussianF_ip_src_gaussianKernel IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        in_0                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_1                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_2                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_3                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_4                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_5                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_6                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_7                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_8                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_0                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_1                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_2                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_3                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_4                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_5                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_6                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_7                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_8                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_valid                          :   IN    std_logic;
        e                                 :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        e_valid                           :   OUT   std_logic
        );
END gaussianF_ip_src_gaussianKernel;


ARCHITECTURE rtl OF gaussianF_ip_src_gaussianKernel IS

  -- Component Declarations
  COMPONENT gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout                            :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_mul_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_add_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : gaussianF_ip_src_SimpleDualPortRAM_generic
    USE ENTITY work.gaussianF_ip_src_SimpleDualPortRAM_generic(rtl);

  FOR ALL : gaussianF_ip_src_nfp_mul_single
    USE ENTITY work.gaussianF_ip_src_nfp_mul_single(rtl);

  FOR ALL : gaussianF_ip_src_nfp_add_single
    USE ENTITY work.gaussianF_ip_src_nfp_add_single(rtl);

  -- Signals
  SIGNAL data                             : matrix_of_std_logic_vector32(0 TO 2, 0 TO 2);  -- ufix32 [3x3]
  SIGNAL c1_data                          : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL delayIn0                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL delayIn1                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL delayIn2                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL delayIn3                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL mergedInput                      : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL mergedDelay_regin                : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL mergedDelay_waddr                : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL mergedDelay_wrenb                : std_logic;  -- ufix1
  SIGNAL mergedDelay_raddr                : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL mergedDelay_regout               : std_logic_vector(127 DOWNTO 0);  -- ufix128
  SIGNAL mergedDelay_regout_unsigned      : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL mergedOutput                     : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL delayIn4                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL delayIn5                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL delayIn6                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL delayIn7                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL mergedInput_1                    : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL mergedDelay_regin_1              : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL mergedDelay_waddr_1              : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL mergedDelay_wrenb_1              : std_logic;  -- ufix1
  SIGNAL mergedDelay_raddr_1              : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL mergedDelay_regout_1             : std_logic_vector(127 DOWNTO 0);  -- ufix128
  SIGNAL mergedDelay_regout_unsigned_1    : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL mergedOutput_1                   : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL slicedInput                      : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL delayOut0                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_1                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL delayOut1                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_2                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL delayOut2                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_3                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL delayOut3                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_4                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL delayOut4                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_5                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL delayOut5                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_6                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL delayOut6                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_7                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL delayOut7                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL delayIn8                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL delayMatch8_regin                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL delayMatch8_waddr                : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL delayMatch8_wrenb                : std_logic;  -- ufix1
  SIGNAL delayMatch8_raddr                : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL delayMatch8_regout               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL in_rsvd                          : matrix_of_std_logic_vector32(0 TO 2, 0 TO 2);  -- ufix32 [3x3]
  SIGNAL c1_in                            : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL delayOut8                        : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL c1_data_1                        : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL c1_temp                          : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL temp                             : matrix_of_std_logic_vector32(0 TO 2, 0 TO 2);  -- ufix32 [3x3]
  SIGNAL In_1_0_2                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL In_1_1_2                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL In_1_2_2                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL sum_op_stage1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL mergedDelay_waddr_2              : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL mergedDelay_wrenb_2              : std_logic;  -- ufix1
  SIGNAL mergedDelay_raddr_2              : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL mergedOutput_2                   : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL slicedInput_8                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL In_1_2_2_1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Out_1_2                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Out_1_2_1                        : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL mergedInput_2                    : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL mergedDelay_regin_2              : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL mergedDelay_regout_2             : std_logic_vector(127 DOWNTO 0);  -- ufix128
  SIGNAL mergedDelay_regout_unsigned_2    : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL sum_op_stage1_1                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_9                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL In_1_0_2_1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Out_1_0                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL sum_op_stage1_2                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_10                   : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL In_1_1_2_1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Out_1_1                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL sum_op_stage1_3                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_11                   : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL In_1_2                           : std_logic_vector(31 DOWNTO 0);  -- ufix32

BEGIN
  u_ShiftRegisterRAM : gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 6,
                 DataWidth => 128
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(mergedDelay_regin),
              wr_addr => std_logic_vector(mergedDelay_waddr),
              wr_en => mergedDelay_wrenb,  -- ufix1
              rd_addr => std_logic_vector(mergedDelay_raddr),
              dout => mergedDelay_regout
              );

  u_ShiftRegisterRAM_1 : gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 6,
                 DataWidth => 128
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(mergedDelay_regin_1),
              wr_addr => std_logic_vector(mergedDelay_waddr_1),
              wr_en => mergedDelay_wrenb_1,  -- ufix1
              rd_addr => std_logic_vector(mergedDelay_raddr_1),
              dout => mergedDelay_regout_1
              );

  u_ShiftRegisterRAM_2 : gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 6,
                 DataWidth => 32
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => delayMatch8_regin,
              wr_addr => std_logic_vector(delayMatch8_waddr),
              wr_en => delayMatch8_wrenb,  -- ufix1
              rd_addr => std_logic_vector(delayMatch8_raddr),
              dout => delayMatch8_regout
              );

  u_nfp_add_comp : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => temp(0, 2),  -- single
              nfp_in2 => temp(1, 2),  -- single
              nfp_out => sum_op_stage1  -- single
              );

  u_nfp_add_comp_1 : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => sum_op_stage1,  -- single
              nfp_in2 => In_1_2_2_1,  -- single
              nfp_out => Out_1_2  -- single
              );

  u_ShiftRegisterRAM_3 : gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 3,
                 DataWidth => 128
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(mergedDelay_regin_2),
              wr_addr => std_logic_vector(mergedDelay_waddr_2),
              wr_en => mergedDelay_wrenb_2,  -- ufix1
              rd_addr => std_logic_vector(mergedDelay_raddr_2),
              dout => mergedDelay_regout_2
              );

  u_nfp_add_comp_2 : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => temp(0, 0),  -- single
              nfp_in2 => temp(1, 0),  -- single
              nfp_out => sum_op_stage1_1  -- single
              );

  u_nfp_add_comp_3 : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => sum_op_stage1_1,  -- single
              nfp_in2 => In_1_0_2_1,  -- single
              nfp_out => Out_1_0  -- single
              );

  u_nfp_add_comp_4 : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => temp(0, 1),  -- single
              nfp_in2 => temp(1, 1),  -- single
              nfp_out => sum_op_stage1_2  -- single
              );

  u_nfp_add_comp_5 : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => sum_op_stage1_2,  -- single
              nfp_in2 => In_1_1_2_1,  -- single
              nfp_out => Out_1_1  -- single
              );

  u_nfp_add_comp_6 : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => Out_1_0,  -- single
              nfp_in2 => Out_1_1,  -- single
              nfp_out => sum_op_stage1_3  -- single
              );

  u_nfp_add_comp_7 : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => sum_op_stage1_3,  -- single
              nfp_in2 => In_1_2,  -- single
              nfp_out => e  -- single
              );

  data(0, 0) <= data_0;
  data(1, 0) <= data_1;
  data(2, 0) <= data_2;
  data(0, 1) <= data_3;
  data(1, 1) <= data_4;
  data(2, 1) <= data_5;
  data(0, 2) <= data_6;
  data(1, 2) <= data_7;
  data(2, 2) <= data_8;

  c1_data_gen1: FOR d1 IN 0 TO 2 GENERATE
    c1_data_gen: FOR d0 IN 0 TO 2 GENERATE
      c1_data(d0 + (d1 * 3)) <= data(d0, d1);
    END GENERATE;
  END GENERATE;

  delayIn0 <= unsigned(c1_data(0));

  delayIn1 <= unsigned(c1_data(1));

  delayIn2 <= unsigned(c1_data(2));

  delayIn3 <= unsigned(c1_data(3));

  mergedInput <= delayIn0 & delayIn1 & delayIn2 & delayIn3;

  -- Input register for RAM-based shift register mergedDelay
  mergedDelay_reginc_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_regin <= to_unsigned(0, 128);
      ELSIF enb = '1' THEN
        mergedDelay_regin <= mergedInput;
      END IF;
    END IF;
  END PROCESS mergedDelay_reginc_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 48
  -- Write address counter for RAM-based shift register mergedDelay
  mergedDelay_wr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_waddr <= to_unsigned(16#00#, 6);
      ELSIF enb = '1' THEN
        IF mergedDelay_waddr >= to_unsigned(16#30#, 6) THEN 
          mergedDelay_waddr <= to_unsigned(16#00#, 6);
        ELSE 
          mergedDelay_waddr <= mergedDelay_waddr + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_wr_process;


  mergedDelay_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 48
  -- Read address counter for RAM-based shift register mergedDelay
  mergedDelay_rd_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_raddr <= to_unsigned(16#01#, 6);
      ELSIF enb = '1' THEN
        IF mergedDelay_raddr >= to_unsigned(16#30#, 6) THEN 
          mergedDelay_raddr <= to_unsigned(16#00#, 6);
        ELSE 
          mergedDelay_raddr <= mergedDelay_raddr + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_rd_process;


  mergedDelay_regout_unsigned <= unsigned(mergedDelay_regout);

  -- Output register for RAM-based shift register mergedDelay
  mergedDelay_regoutc_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedOutput <= to_unsigned(0, 128);
      ELSIF enb = '1' THEN
        mergedOutput <= mergedDelay_regout_unsigned;
      END IF;
    END IF;
  END PROCESS mergedDelay_regoutc_process;


  delayIn4 <= unsigned(c1_data(4));

  delayIn5 <= unsigned(c1_data(5));

  delayIn6 <= unsigned(c1_data(6));

  delayIn7 <= unsigned(c1_data(7));

  mergedInput_1 <= delayIn4 & delayIn5 & delayIn6 & delayIn7;

  -- Input register for RAM-based shift register mergedDelay
  mergedDelay_reginc_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_regin_1 <= to_unsigned(0, 128);
      ELSIF enb = '1' THEN
        mergedDelay_regin_1 <= mergedInput_1;
      END IF;
    END IF;
  END PROCESS mergedDelay_reginc_1_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 48
  -- Write address counter for RAM-based shift register mergedDelay
  mergedDelay_wr_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_waddr_1 <= to_unsigned(16#00#, 6);
      ELSIF enb = '1' THEN
        IF mergedDelay_waddr_1 >= to_unsigned(16#30#, 6) THEN 
          mergedDelay_waddr_1 <= to_unsigned(16#00#, 6);
        ELSE 
          mergedDelay_waddr_1 <= mergedDelay_waddr_1 + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_wr_1_process;


  mergedDelay_wrenb_1 <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 48
  -- Read address counter for RAM-based shift register mergedDelay
  mergedDelay_rd_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_raddr_1 <= to_unsigned(16#01#, 6);
      ELSIF enb = '1' THEN
        IF mergedDelay_raddr_1 >= to_unsigned(16#30#, 6) THEN 
          mergedDelay_raddr_1 <= to_unsigned(16#00#, 6);
        ELSE 
          mergedDelay_raddr_1 <= mergedDelay_raddr_1 + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_rd_1_process;


  mergedDelay_regout_unsigned_1 <= unsigned(mergedDelay_regout_1);

  -- Output register for RAM-based shift register mergedDelay
  mergedDelay_regoutc_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedOutput_1 <= to_unsigned(0, 128);
      ELSIF enb = '1' THEN
        mergedOutput_1 <= mergedDelay_regout_unsigned_1;
      END IF;
    END IF;
  END PROCESS mergedDelay_regoutc_1_process;


  slicedInput <= mergedOutput(127 DOWNTO 96);

  delayOut0 <= std_logic_vector(resize(slicedInput, 32));

  slicedInput_1 <= mergedOutput(95 DOWNTO 64);

  delayOut1 <= std_logic_vector(resize(slicedInput_1, 32));

  slicedInput_2 <= mergedOutput(63 DOWNTO 32);

  delayOut2 <= std_logic_vector(resize(slicedInput_2, 32));

  slicedInput_3 <= mergedOutput(31 DOWNTO 0);

  delayOut3 <= std_logic_vector(resize(slicedInput_3, 32));

  slicedInput_4 <= mergedOutput_1(127 DOWNTO 96);

  delayOut4 <= std_logic_vector(resize(slicedInput_4, 32));

  slicedInput_5 <= mergedOutput_1(95 DOWNTO 64);

  delayOut5 <= std_logic_vector(resize(slicedInput_5, 32));

  slicedInput_6 <= mergedOutput_1(63 DOWNTO 32);

  delayOut6 <= std_logic_vector(resize(slicedInput_6, 32));

  slicedInput_7 <= mergedOutput_1(31 DOWNTO 0);

  delayOut7 <= std_logic_vector(resize(slicedInput_7, 32));

  delayIn8 <= c1_data(8);

  -- Input register for RAM-based shift register delayMatch8
  delayMatch8_reginc_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch8_regin <= X"00000000";
      ELSIF enb = '1' THEN
        delayMatch8_regin <= delayIn8;
      END IF;
    END IF;
  END PROCESS delayMatch8_reginc_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 48
  -- Write address counter for RAM-based shift register delayMatch8
  delayMatch8_wr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch8_waddr <= to_unsigned(16#00#, 6);
      ELSIF enb = '1' THEN
        IF delayMatch8_waddr >= to_unsigned(16#30#, 6) THEN 
          delayMatch8_waddr <= to_unsigned(16#00#, 6);
        ELSE 
          delayMatch8_waddr <= delayMatch8_waddr + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS delayMatch8_wr_process;


  delayMatch8_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 48
  -- Read address counter for RAM-based shift register delayMatch8
  delayMatch8_rd_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch8_raddr <= to_unsigned(16#01#, 6);
      ELSIF enb = '1' THEN
        IF delayMatch8_raddr >= to_unsigned(16#30#, 6) THEN 
          delayMatch8_raddr <= to_unsigned(16#00#, 6);
        ELSE 
          delayMatch8_raddr <= delayMatch8_raddr + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS delayMatch8_rd_process;


  in_rsvd(0, 0) <= in_0;
  in_rsvd(1, 0) <= in_1;
  in_rsvd(2, 0) <= in_2;
  in_rsvd(0, 1) <= in_3;
  in_rsvd(1, 1) <= in_4;
  in_rsvd(2, 1) <= in_5;
  in_rsvd(0, 2) <= in_6;
  in_rsvd(1, 2) <= in_7;
  in_rsvd(2, 2) <= in_8;

  c1_in_gen1: FOR d1 IN 0 TO 2 GENERATE
    c1_in_gen: FOR d0 IN 0 TO 2 GENERATE
      c1_in(d0 + (d1 * 3)) <= in_rsvd(d0, d1);
    END GENERATE;
  END GENERATE;

  -- Output register for RAM-based shift register delayMatch8
  delayMatch8_regoutc_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayOut8 <= X"00000000";
      ELSIF enb = '1' THEN
        delayOut8 <= delayMatch8_regout;
      END IF;
    END IF;
  END PROCESS delayMatch8_regoutc_process;


  c1_data_1(0) <= delayOut0;
  c1_data_1(1) <= delayOut1;
  c1_data_1(2) <= delayOut2;
  c1_data_1(3) <= delayOut3;
  c1_data_1(4) <= delayOut4;
  c1_data_1(5) <= delayOut5;
  c1_data_1(6) <= delayOut6;
  c1_data_1(7) <= delayOut7;
  c1_data_1(8) <= delayOut8;

  u_nfp_mul_comp_gen: FOR k IN 0 TO 8 GENERATE
    u_nfp_mul_comp : gaussianF_ip_src_nfp_mul_single
      PORT MAP( clk => clk,
                reset => reset,
                enb => enb,
                nfp_in1 => c1_in(k),  -- ufix32
                nfp_in2 => c1_data_1(k),  -- ufix32
                nfp_out => c1_temp(k)  -- ufix32
                );
  END GENERATE;

  temp_gen1: FOR d1 IN 0 TO 2 GENERATE
    temp_gen: FOR d0 IN 0 TO 2 GENERATE
      temp(d0, d1) <= c1_temp(d0 + (d1 * 3));
    END GENERATE;
  END GENERATE;

  In_1_0_2 <= unsigned(temp(2, 0));

  In_1_1_2 <= unsigned(temp(2, 1));

  In_1_2_2 <= unsigned(temp(2, 2));

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 3
  -- Write address counter for RAM-based shift register mergedDelay
  mergedDelay_wr_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_waddr_2 <= to_unsigned(16#0#, 3);
      ELSIF enb = '1' THEN
        IF mergedDelay_waddr_2 >= to_unsigned(16#3#, 3) THEN 
          mergedDelay_waddr_2 <= to_unsigned(16#0#, 3);
        ELSE 
          mergedDelay_waddr_2 <= mergedDelay_waddr_2 + to_unsigned(16#1#, 3);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_wr_2_process;


  mergedDelay_wrenb_2 <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 3
  -- Read address counter for RAM-based shift register mergedDelay
  mergedDelay_rd_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_raddr_2 <= to_unsigned(16#1#, 3);
      ELSIF enb = '1' THEN
        IF mergedDelay_raddr_2 >= to_unsigned(16#3#, 3) THEN 
          mergedDelay_raddr_2 <= to_unsigned(16#0#, 3);
        ELSE 
          mergedDelay_raddr_2 <= mergedDelay_raddr_2 + to_unsigned(16#1#, 3);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_rd_2_process;


  slicedInput_8 <= mergedOutput_2(63 DOWNTO 32);

  In_1_2_2_1 <= std_logic_vector(resize(slicedInput_8, 32));

  Out_1_2_1 <= unsigned(Out_1_2);

  mergedInput_2 <= In_1_0_2 & In_1_1_2 & In_1_2_2 & Out_1_2_1;

  -- Input register for RAM-based shift register mergedDelay
  mergedDelay_reginc_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_regin_2 <= to_unsigned(0, 128);
      ELSIF enb = '1' THEN
        mergedDelay_regin_2 <= mergedInput_2;
      END IF;
    END IF;
  END PROCESS mergedDelay_reginc_2_process;


  mergedDelay_regout_unsigned_2 <= unsigned(mergedDelay_regout_2);

  -- Output register for RAM-based shift register mergedDelay
  mergedDelay_regoutc_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedOutput_2 <= to_unsigned(0, 128);
      ELSIF enb = '1' THEN
        mergedOutput_2 <= mergedDelay_regout_unsigned_2;
      END IF;
    END IF;
  END PROCESS mergedDelay_regoutc_2_process;


  slicedInput_9 <= mergedOutput_2(127 DOWNTO 96);

  In_1_0_2_1 <= std_logic_vector(resize(slicedInput_9, 32));

  slicedInput_10 <= mergedOutput_2(95 DOWNTO 64);

  In_1_1_2_1 <= std_logic_vector(resize(slicedInput_10, 32));

  slicedInput_11 <= mergedOutput_2(31 DOWNTO 0);

  In_1_2 <= std_logic_vector(resize(slicedInput_11, 32));

  e_valid <= in_valid;

END rtl;

