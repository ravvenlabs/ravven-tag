-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj1\hdlsrc\gaussianFilter\gaussianF_ip_src_BoundaryCheck_3x3.vhd
-- Created: 2024-06-04 12:57:05
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: gaussianF_ip_src_BoundaryCheck_3x3
-- Source Path: BoundaryCheck_3x3
-- Hierarchy Level: 3
-- Model version: 8.37
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.gaussianF_ip_src_gaussianFilter_pkg.ALL;

ENTITY gaussianF_ip_src_BoundaryCheck_3x3 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        maxNeighborhood_0                 :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        maxNeighborhood_1                 :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        maxNeighborhood_2                 :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        maxNeighborhood_3                 :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        maxNeighborhood_4                 :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        maxNeighborhood_5                 :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        maxNeighborhood_6                 :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        maxNeighborhood_7                 :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        maxNeighborhood_8                 :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        rowCtr                            :   IN    std_logic_vector(8 DOWNTO 0);  -- ufix9
        colCtr                            :   IN    std_logic_vector(9 DOWNTO 0);  -- ufix10
        shift                             :   IN    std_logic;  -- ufix1
        neighborhood_3x3_0                :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_3x3_1                :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_3x3_2                :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_3x3_3                :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_3x3_4                :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_3x3_5                :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_3x3_6                :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_3x3_7                :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_3x3_8                :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
        );
END gaussianF_ip_src_BoundaryCheck_3x3;


ARCHITECTURE rtl OF gaussianF_ip_src_BoundaryCheck_3x3 IS

  -- Component Declarations
  COMPONENT gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout                            :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : gaussianF_ip_src_SimpleDualPortRAM_generic
    USE ENTITY work.gaussianF_ip_src_SimpleDualPortRAM_generic(rtl);

  -- Signals
  SIGNAL baseIdxs_1                       : vector_of_unsigned2(0 TO 2);  -- ufix2 [3]
  SIGNAL shiftedIdxs_v                    : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL shiftedIdxs_1                    : vector_of_unsigned3(0 TO 2);  -- ufix3 [3]
  SIGNAL idxs_1                           : vector_of_unsigned3(0 TO 2);  -- ufix3 [3]
  SIGNAL idxs_2                           : vector_of_unsigned2(0 TO 2);  -- ufix2 [3]
  SIGNAL delayIn0                         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL delayIn1                         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL delayIn2                         : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL enb_2                            : std_logic;
  SIGNAL rowCtr_unsigned                  : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL row_gt_1_1                       : std_logic;
  SIGNAL row_lt_3_1                       : std_logic;
  SIGNAL row_gt_1_lt_3_1                  : std_logic;
  SIGNAL colCtr_unsigned                  : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL col_gt_1_1                       : std_logic;
  SIGNAL col_lt_3_1                       : std_logic;
  SIGNAL col_gt_1_lt_3_1                  : std_logic;
  SIGNAL outOfBounds_1_1_1                : std_logic;
  SIGNAL row_lt_2_1                       : std_logic;
  SIGNAL outOfBounds_3_1_1                : std_logic;
  SIGNAL col_lt_2_1                       : std_logic;
  SIGNAL outOfBounds_1_3_1                : std_logic;
  SIGNAL outOfBounds_3_3_1                : std_logic;
  SIGNAL mergedInput                      : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL mergedDelay_regin                : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL mergedDelay_waddr                : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL mergedDelay_wrenb                : std_logic;  -- ufix1
  SIGNAL mergedDelay_raddr                : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL mergedDelay_regout               : std_logic_vector(14 DOWNTO 0);  -- ufix15
  SIGNAL mergedDelay_regout_unsigned      : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL mergedOutput                     : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL slicedInput                      : std_logic;  -- ufix1
  SIGNAL outOfBounds_1_1_2                : std_logic;
  SIGNAL slicedInput_1                    : std_logic;  -- ufix1
  SIGNAL enb_3                            : std_logic;
  SIGNAL maxNeighborhood                  : matrix_of_std_logic_vector32(0 TO 2, 0 TO 2);  -- ufix32 [3x3]
  SIGNAL c46_maxNeighborhood              : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL maxNeighborhood_9                : matrix_of_std_logic_vector32(0 TO 2, 0 TO 2);  -- ufix32 [3x3]
  SIGNAL c45_maxNeighborhood              : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL c45_maxNeighborhood_hold         : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL c46_maxNeighborhood_1            : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL slicedInput_2                    : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL delayOut0                        : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL k0                               : vector_of_unsigned2(0 TO 2);  -- ufix2 [3]
  SIGNAL k0_0                             : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL idxs_zp_0                        : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL slicedInput_3                    : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL delayOut1                        : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL switch_compare_2                 : std_logic;
  SIGNAL k0_1                             : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL idxs_zp_1                        : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL slicedInput_4                    : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL delayOut2                        : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL switch_compare_3                 : std_logic;
  SIGNAL k0_2                             : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL idxs_zp_2                        : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL idxs_zp                          : vector_of_unsigned2(0 TO 2);  -- ufix2 [3]
  SIGNAL neighborhood                     : matrix_of_std_logic_vector32(0 TO 2, 0 TO 2);  -- ufix32 [3x3]
  SIGNAL neighborhood_col1_0              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL boundaryConst_1                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL mask_1_1_OOB_1                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_5                    : std_logic;  -- ufix1
  SIGNAL col_gt_1_lt_3_2                  : std_logic;
  SIGNAL neighborhood_col1_1              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL mask_2_1_col_OOB_1               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_6                    : std_logic;  -- ufix1
  SIGNAL outOfBounds_3_1_2                : std_logic;
  SIGNAL neighborhood_col1_2              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_7                    : std_logic;  -- ufix1
  SIGNAL row_gt_1_lt_3_2                  : std_logic;
  SIGNAL neighborhood_col2_0              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL mask_1_2_row_OOB_1               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_8                    : std_logic;  -- ufix1
  SIGNAL row_lt_2_2                       : std_logic;
  SIGNAL neighborhood_col2_2              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_9                    : std_logic;  -- ufix1
  SIGNAL outOfBounds_1_3_2                : std_logic;
  SIGNAL neighborhood_col3_0              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL mask_1_3_OOB_1                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_10                   : std_logic;  -- ufix1
  SIGNAL col_lt_2_2                       : std_logic;
  SIGNAL neighborhood_col3_1              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL mask_2_3_col_OOB_1               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_11                   : std_logic;  -- ufix1
  SIGNAL outOfBounds_3_3_2                : std_logic;
  SIGNAL neighborhood_col3_2              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL mask_3_1_OOB_1                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL neighborhood_masked_col1         : vector_of_std_logic_vector32(0 TO 2);  -- ufix32 [3]
  SIGNAL mask_3_2_row_OOB_1               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL neighborhood_masked_col2         : vector_of_std_logic_vector32(0 TO 2);  -- ufix32 [3]
  SIGNAL mask_3_3_OOB_1                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL neighborhood_masked_col3         : vector_of_std_logic_vector32(0 TO 2);  -- ufix32 [3]
  SIGNAL neighborhood_masked              : matrix_of_std_logic_vector32(0 TO 2, 0 TO 2);  -- ufix32 [3x3]

BEGIN
  u_ShiftRegisterRAM : gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 6,
                 DataWidth => 15
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(mergedDelay_regin),
              wr_addr => std_logic_vector(mergedDelay_waddr),
              wr_en => mergedDelay_wrenb,  -- ufix1
              rd_addr => std_logic_vector(mergedDelay_raddr),
              dout => mergedDelay_regout
              );

  baseIdxs_1(0) <= to_unsigned(16#1#, 2);
  baseIdxs_1(1) <= to_unsigned(16#2#, 2);
  baseIdxs_1(2) <= to_unsigned(16#3#, 2);

  shiftedIdxs_v <= '0' & '0' & shift;

  shiftedIdxs_1_gen: FOR t_0 IN 0 TO 2 GENERATE
    shiftedIdxs_1(t_0) <= resize(baseIdxs_1(t_0), 3) + shiftedIdxs_v;
  END GENERATE shiftedIdxs_1_gen;


  idxs_output : PROCESS (shiftedIdxs_1)
  BEGIN

    FOR ii IN 0 TO 2 LOOP
      IF shiftedIdxs_1(ii) > to_unsigned(16#3#, 3) THEN 
        idxs_1(ii) <= to_unsigned(16#3#, 3);
      ELSIF shiftedIdxs_1(ii) < to_unsigned(16#1#, 3) THEN 
        idxs_1(ii) <= to_unsigned(16#1#, 3);
      ELSE 
        idxs_1(ii) <= shiftedIdxs_1(ii);
      END IF;
    END LOOP;

  END PROCESS idxs_output;



  idxs_2_gen: FOR ii1 IN 0 TO 2 GENERATE
    idxs_2(ii1) <= idxs_1(ii1)(1 DOWNTO 0);
  END GENERATE idxs_2_gen;


  delayIn0 <= idxs_2(0);

  delayIn1 <= idxs_2(1);

  delayIn2 <= idxs_2(2);

  
  enb_2 <= '1' WHEN shift = '0' ELSE
      '0';

  rowCtr_unsigned <= unsigned(rowCtr);

  
  row_gt_1_1 <= '1' WHEN rowCtr_unsigned > to_unsigned(16#001#, 9) ELSE
      '0';

  
  row_lt_3_1 <= '1' WHEN rowCtr_unsigned < to_unsigned(16#003#, 9) ELSE
      '0';

  row_gt_1_lt_3_1 <= row_gt_1_1 AND row_lt_3_1;

  colCtr_unsigned <= unsigned(colCtr);

  
  col_gt_1_1 <= '1' WHEN colCtr_unsigned > to_unsigned(16#001#, 10) ELSE
      '0';

  
  col_lt_3_1 <= '1' WHEN colCtr_unsigned < to_unsigned(16#003#, 10) ELSE
      '0';

  col_gt_1_lt_3_1 <= col_gt_1_1 AND col_lt_3_1;

  outOfBounds_1_1_1 <= row_gt_1_lt_3_1 OR col_gt_1_lt_3_1;

  
  row_lt_2_1 <= '1' WHEN rowCtr_unsigned < to_unsigned(16#002#, 9) ELSE
      '0';

  outOfBounds_3_1_1 <= row_lt_2_1 OR col_gt_1_lt_3_1;

  
  col_lt_2_1 <= '1' WHEN colCtr_unsigned < to_unsigned(16#002#, 10) ELSE
      '0';

  outOfBounds_1_3_1 <= row_gt_1_lt_3_1 OR col_lt_2_1;

  outOfBounds_3_3_1 <= row_lt_2_1 OR col_lt_2_1;

  mergedInput <= delayIn0 & delayIn1 & delayIn2 & unsigned'(enb_2 & outOfBounds_1_1_1 & col_gt_1_lt_3_1 & outOfBounds_3_1_1 & row_gt_1_lt_3_1 & row_lt_2_1 & outOfBounds_1_3_1 & col_lt_2_1 & outOfBounds_3_3_1);

  -- Input register for RAM-based shift register mergedDelay
  mergedDelay_reginc_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_regin <= to_unsigned(16#0000#, 15);
      ELSIF enb = '1' THEN
        mergedDelay_regin <= mergedInput;
      END IF;
    END IF;
  END PROCESS mergedDelay_reginc_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 48
  -- Write address counter for RAM-based shift register mergedDelay
  mergedDelay_wr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_waddr <= to_unsigned(16#00#, 6);
      ELSIF enb = '1' THEN
        IF mergedDelay_waddr >= to_unsigned(16#30#, 6) THEN 
          mergedDelay_waddr <= to_unsigned(16#00#, 6);
        ELSE 
          mergedDelay_waddr <= mergedDelay_waddr + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_wr_process;


  mergedDelay_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 48
  -- Read address counter for RAM-based shift register mergedDelay
  mergedDelay_rd_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_raddr <= to_unsigned(16#01#, 6);
      ELSIF enb = '1' THEN
        IF mergedDelay_raddr >= to_unsigned(16#30#, 6) THEN 
          mergedDelay_raddr <= to_unsigned(16#00#, 6);
        ELSE 
          mergedDelay_raddr <= mergedDelay_raddr + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_rd_process;


  mergedDelay_regout_unsigned <= unsigned(mergedDelay_regout);

  -- Output register for RAM-based shift register mergedDelay
  mergedDelay_regoutc_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedOutput <= to_unsigned(16#0000#, 15);
      ELSIF enb = '1' THEN
        mergedOutput <= mergedDelay_regout_unsigned;
      END IF;
    END IF;
  END PROCESS mergedDelay_regoutc_process;


  slicedInput <= mergedOutput(7);

  outOfBounds_1_1_2 <= slicedInput;

  slicedInput_1 <= mergedOutput(8);

  enb_3 <= slicedInput_1;

  maxNeighborhood(0, 0) <= maxNeighborhood_0;
  maxNeighborhood(1, 0) <= maxNeighborhood_1;
  maxNeighborhood(2, 0) <= maxNeighborhood_2;
  maxNeighborhood(0, 1) <= maxNeighborhood_3;
  maxNeighborhood(1, 1) <= maxNeighborhood_4;
  maxNeighborhood(2, 1) <= maxNeighborhood_5;
  maxNeighborhood(0, 2) <= maxNeighborhood_6;
  maxNeighborhood(1, 2) <= maxNeighborhood_7;
  maxNeighborhood(2, 2) <= maxNeighborhood_8;

  c46_maxNeighborhood_gen1: FOR d1 IN 0 TO 2 GENERATE
    c46_maxNeighborhood_gen: FOR d0 IN 0 TO 2 GENERATE
      c46_maxNeighborhood(d0 + (d1 * 3)) <= maxNeighborhood(d0, d1);
    END GENERATE;
  END GENERATE;

  c45_maxNeighborhood_gen1: FOR d1 IN 0 TO 2 GENERATE
    c45_maxNeighborhood_gen: FOR d0 IN 0 TO 2 GENERATE
      c45_maxNeighborhood(d0 + (d1 * 3)) <= maxNeighborhood_9(d0, d1);
    END GENERATE;
  END GENERATE;

  maxNeighborhood_hold_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        c45_maxNeighborhood_hold <= (OTHERS => X"00000000");
      ELSIF enb = '1' THEN
        c45_maxNeighborhood_hold <= c45_maxNeighborhood;
      END IF;
    END IF;
  END PROCESS maxNeighborhood_hold_process;


  
  c46_maxNeighborhood_1 <= c45_maxNeighborhood_hold WHEN enb_3 = '0' ELSE
      c46_maxNeighborhood;

  maxNeighborhood_9_gen1: FOR d1 IN 0 TO 2 GENERATE
    maxNeighborhood_9_gen: FOR d0 IN 0 TO 2 GENERATE
      maxNeighborhood_9(d0, d1) <= c46_maxNeighborhood_1(d0 + (d1 * 3));
    END GENERATE;
  END GENERATE;

  slicedInput_2 <= mergedOutput(14 DOWNTO 13);

  delayOut0 <= slicedInput_2;

  
  switch_compare_1 <= '1' WHEN delayOut0 >= to_unsigned(16#1#, 2) ELSE
      '0';

  k0 <= (OTHERS => to_unsigned(16#1#, 2));

  k0_0 <= k0(0);

  
  idxs_zp_0 <= k0_0 WHEN switch_compare_1 = '0' ELSE
      delayOut0;

  slicedInput_3 <= mergedOutput(12 DOWNTO 11);

  delayOut1 <= slicedInput_3;

  
  switch_compare_2 <= '1' WHEN delayOut1 >= to_unsigned(16#1#, 2) ELSE
      '0';

  k0_1 <= k0(1);

  
  idxs_zp_1 <= k0_1 WHEN switch_compare_2 = '0' ELSE
      delayOut1;

  slicedInput_4 <= mergedOutput(10 DOWNTO 9);

  delayOut2 <= slicedInput_4;

  
  switch_compare_3 <= '1' WHEN delayOut2 >= to_unsigned(16#1#, 2) ELSE
      '0';

  k0_2 <= k0(2);

  
  idxs_zp_2 <= k0_2 WHEN switch_compare_3 = '0' ELSE
      delayOut2;

  idxs_zp(0) <= idxs_zp_0;
  idxs_zp(1) <= idxs_zp_1;
  idxs_zp(2) <= idxs_zp_2;

  Selector_output : PROCESS (idxs_zp, maxNeighborhood_9)
  BEGIN

    FOR t_01 IN 0 TO 2 LOOP
      neighborhood(t_01, 0) <= maxNeighborhood_9(t_01, 2);
    END LOOP;

    IF idxs_zp(0) = to_unsigned(16#2#, 2) THEN 
      FOR t_1 IN 0 TO 2 LOOP
        neighborhood(t_1, 0) <= maxNeighborhood_9(t_1, 1);
      END LOOP;
    END IF;
    IF idxs_zp(0) = to_unsigned(16#1#, 2) THEN 
      FOR t_2 IN 0 TO 2 LOOP
        neighborhood(t_2, 0) <= maxNeighborhood_9(t_2, 0);
      END LOOP;
    END IF;

    FOR t_3 IN 0 TO 2 LOOP
      neighborhood(t_3, 1) <= maxNeighborhood_9(t_3, 2);
    END LOOP;

    IF idxs_zp(1) = to_unsigned(16#2#, 2) THEN 
      FOR t_4 IN 0 TO 2 LOOP
        neighborhood(t_4, 1) <= maxNeighborhood_9(t_4, 1);
      END LOOP;
    END IF;
    IF idxs_zp(1) = to_unsigned(16#1#, 2) THEN 
      FOR t_5 IN 0 TO 2 LOOP
        neighborhood(t_5, 1) <= maxNeighborhood_9(t_5, 0);
      END LOOP;
    END IF;

    FOR t_6 IN 0 TO 2 LOOP
      neighborhood(t_6, 2) <= maxNeighborhood_9(t_6, 2);
    END LOOP;

    IF idxs_zp(2) = to_unsigned(16#2#, 2) THEN 
      FOR t_7 IN 0 TO 2 LOOP
        neighborhood(t_7, 2) <= maxNeighborhood_9(t_7, 1);
      END LOOP;
    END IF;
    IF idxs_zp(2) = to_unsigned(16#1#, 2) THEN 
      FOR t_8 IN 0 TO 2 LOOP
        neighborhood(t_8, 2) <= maxNeighborhood_9(t_8, 0);
      END LOOP;
    END IF;
  END PROCESS Selector_output;


  neighborhood_col1_0 <= neighborhood(0, 0);

  boundaryConst_1 <= X"00000000";

  
  mask_1_1_OOB_1 <= neighborhood_col1_0 WHEN outOfBounds_1_1_2 = '0' ELSE
      boundaryConst_1;

  slicedInput_5 <= mergedOutput(6);

  col_gt_1_lt_3_2 <= slicedInput_5;

  neighborhood_col1_1 <= neighborhood(1, 0);

  
  mask_2_1_col_OOB_1 <= neighborhood_col1_1 WHEN col_gt_1_lt_3_2 = '0' ELSE
      boundaryConst_1;

  slicedInput_6 <= mergedOutput(5);

  outOfBounds_3_1_2 <= slicedInput_6;

  neighborhood_col1_2 <= neighborhood(2, 0);

  slicedInput_7 <= mergedOutput(4);

  row_gt_1_lt_3_2 <= slicedInput_7;

  neighborhood_col2_0 <= neighborhood(0, 1);

  
  mask_1_2_row_OOB_1 <= neighborhood_col2_0 WHEN row_gt_1_lt_3_2 = '0' ELSE
      boundaryConst_1;

  slicedInput_8 <= mergedOutput(3);

  row_lt_2_2 <= slicedInput_8;

  neighborhood_col2_2 <= neighborhood(2, 1);

  slicedInput_9 <= mergedOutput(2);

  outOfBounds_1_3_2 <= slicedInput_9;

  neighborhood_col3_0 <= neighborhood(0, 2);

  
  mask_1_3_OOB_1 <= neighborhood_col3_0 WHEN outOfBounds_1_3_2 = '0' ELSE
      boundaryConst_1;

  slicedInput_10 <= mergedOutput(1);

  col_lt_2_2 <= slicedInput_10;

  neighborhood_col3_1 <= neighborhood(1, 2);

  
  mask_2_3_col_OOB_1 <= neighborhood_col3_1 WHEN col_lt_2_2 = '0' ELSE
      boundaryConst_1;

  slicedInput_11 <= mergedOutput(0);

  outOfBounds_3_3_2 <= slicedInput_11;

  neighborhood_col3_2 <= neighborhood(2, 2);

  
  mask_3_1_OOB_1 <= neighborhood_col1_2 WHEN outOfBounds_3_1_2 = '0' ELSE
      boundaryConst_1;

  neighborhood_masked_col1(0) <= mask_1_1_OOB_1;
  neighborhood_masked_col1(1) <= mask_2_1_col_OOB_1;
  neighborhood_masked_col1(2) <= mask_3_1_OOB_1;

  
  mask_3_2_row_OOB_1 <= neighborhood_col2_2 WHEN row_lt_2_2 = '0' ELSE
      boundaryConst_1;

  neighborhood_masked_col2(0) <= mask_1_2_row_OOB_1;
  neighborhood_masked_col2(1) <= neighborhood(1, 1);
  neighborhood_masked_col2(2) <= mask_3_2_row_OOB_1;

  
  mask_3_3_OOB_1 <= neighborhood_col3_2 WHEN outOfBounds_3_3_2 = '0' ELSE
      boundaryConst_1;

  neighborhood_masked_col3(0) <= mask_1_3_OOB_1;
  neighborhood_masked_col3(1) <= mask_2_3_col_OOB_1;
  neighborhood_masked_col3(2) <= mask_3_3_OOB_1;

  neighborhood_masked_gen: FOR idx IN 0 TO 2 GENERATE
    neighborhood_masked(idx, 0) <= neighborhood_masked_col1(idx);
  END GENERATE;
  neighborhood_masked_gen1: FOR idx IN 0 TO 2 GENERATE
    neighborhood_masked(idx, 1) <= neighborhood_masked_col2(idx);
  END GENERATE;
  neighborhood_masked_gen2: FOR idx IN 0 TO 2 GENERATE
    neighborhood_masked(idx, 2) <= neighborhood_masked_col3(idx);
  END GENERATE;

  neighborhood_3x3_0 <= neighborhood_masked(0, 0);

  neighborhood_3x3_1 <= neighborhood_masked(1, 0);

  neighborhood_3x3_2 <= neighborhood_masked(2, 0);

  neighborhood_3x3_3 <= neighborhood_masked(0, 1);

  neighborhood_3x3_4 <= neighborhood_masked(1, 1);

  neighborhood_3x3_5 <= neighborhood_masked(2, 1);

  neighborhood_3x3_6 <= neighborhood_masked(0, 2);

  neighborhood_3x3_7 <= neighborhood_masked(1, 2);

  neighborhood_3x3_8 <= neighborhood_masked(2, 2);

END rtl;

