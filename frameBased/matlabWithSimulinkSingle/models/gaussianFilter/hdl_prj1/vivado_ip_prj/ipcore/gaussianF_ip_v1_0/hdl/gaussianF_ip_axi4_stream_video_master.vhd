-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj1\hdlsrc\gaussianFilter\gaussianF_ip_axi4_stream_video_master.vhd
-- Created: 2024-06-04 12:57:18
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: gaussianF_ip_axi4_stream_video_master
-- Source Path: gaussianF_ip/gaussianF_ip_axi4_stream_video_master
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY gaussianF_ip_axi4_stream_video_master IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        AXI4_Stream_Video_Master_TREADY   :   IN    std_logic;  -- ufix1
        user_pixel                        :   IN    std_logic_vector(63 DOWNTO 0);  -- ufix64
        user_valid                        :   IN    std_logic;  -- ufix1
        adapter_active_frame              :   IN    std_logic;  -- ufix1
        adapter_partial_frame             :   IN    std_logic;  -- ufix1
        adapter_hPorch                    :   IN    std_logic_vector(12 DOWNTO 0);  -- ufix13
        AXI4_Stream_Video_Master_TDATA    :   OUT   std_logic_vector(63 DOWNTO 0);  -- ufix64
        AXI4_Stream_Video_Master_TVALID   :   OUT   std_logic;  -- ufix1
        AXI4_Stream_Video_Master_TLAST    :   OUT   std_logic;  -- ufix1
        AXI4_Stream_Video_Master_TUSER    :   OUT   std_logic;  -- ufix1
        user_ready                        :   OUT   std_logic  -- ufix1
        );
END gaussianF_ip_axi4_stream_video_master;


ARCHITECTURE rtl OF gaussianF_ip_axi4_stream_video_master IS

  -- Component Declarations
  COMPONENT gaussianF_ip_adapter_fifo
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          In_rsvd                         :   IN    std_logic_vector(63 DOWNTO 0);  -- ufix64
          Push                            :   IN    std_logic;  -- ufix1
          Pop                             :   IN    std_logic;  -- ufix1
          reset_1                         :   IN    std_logic;  -- ufix1
          Out_rsvd                        :   OUT   std_logic_vector(63 DOWNTO 0);  -- ufix64
          AFull                           :   OUT   std_logic;  -- ufix1
          Num                             :   OUT   std_logic_vector(10 DOWNTO 0)  -- ufix11
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_fifo_data_OUT
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          In_rsvd                         :   IN    std_logic_vector(63 DOWNTO 0);  -- ufix64
          Push                            :   IN    std_logic;  -- ufix1
          Pop                             :   IN    std_logic;  -- ufix1
          Out_rsvd                        :   OUT   std_logic_vector(63 DOWNTO 0);  -- ufix64
          Empty                           :   OUT   std_logic;  -- ufix1
          AFull                           :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_fifo_eol_out
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          In_rsvd                         :   IN    std_logic;  -- ufix1
          Push                            :   IN    std_logic;  -- ufix1
          Pop                             :   IN    std_logic;  -- ufix1
          Out_rsvd                        :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_fifo_sof_out
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          In_rsvd                         :   IN    std_logic;  -- ufix1
          Push                            :   IN    std_logic;  -- ufix1
          Pop                             :   IN    std_logic;  -- ufix1
          Out_rsvd                        :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : gaussianF_ip_adapter_fifo
    USE ENTITY work.gaussianF_ip_adapter_fifo(rtl);

  FOR ALL : gaussianF_ip_fifo_data_OUT
    USE ENTITY work.gaussianF_ip_fifo_data_OUT(rtl);

  FOR ALL : gaussianF_ip_fifo_eol_out
    USE ENTITY work.gaussianF_ip_fifo_eol_out(rtl);

  FOR ALL : gaussianF_ip_fifo_sof_out
    USE ENTITY work.gaussianF_ip_fifo_sof_out(rtl);

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL line_length                      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL adapter_hPorch_unsigned          : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL const_three                      : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL internal_ready                   : std_logic;  -- ufix1
  SIGNAL control_valid                    : std_logic;  -- ufix1
  SIGNAL fifo_push                        : std_logic;  -- ufix1
  SIGNAL hp_fifo_afull                    : std_logic;  -- ufix1
  SIGNAL hp_fifo_not_full                 : std_logic;  -- ufix1
  SIGNAL hp_fifo_num_unsigned             : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL FIFO_not_empty                   : std_logic;  -- ufix1
  SIGNAL fifo_afull_data                  : std_logic;  -- ufix1
  SIGNAL adapter_f2s_ready                : std_logic;  -- ufix1
  SIGNAL hp_fifo_num                      : std_logic_vector(10 DOWNTO 0);  -- ufix11
  SIGNAL fifo_full_line                   : std_logic;  -- ufix1
  SIGNAL axi4_video_F2S_out_state         : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL axi4_video_F2S_out_state_not_empty : std_logic;
  SIGNAL axi4_video_F2S_out_hPos          : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL axi4_video_F2S_out_vPos          : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL axi4_video_F2S_out_valid         : std_logic;
  SIGNAL axi4_video_F2S_out_vStart        : std_logic;
  SIGNAL axi4_video_F2S_out_hEnd          : std_logic;
  SIGNAL axi4_video_F2S_out_blankCnt      : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL axi4_video_F2S_out_state_next    : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL axi4_video_F2S_out_state_not_empty_next : std_logic;
  SIGNAL axi4_video_F2S_out_hPos_next     : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL axi4_video_F2S_out_vPos_next     : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL axi4_video_F2S_out_valid_next    : std_logic;
  SIGNAL axi4_video_F2S_out_vStart_next   : std_logic;
  SIGNAL axi4_video_F2S_out_hEnd_next     : std_logic;
  SIGNAL axi4_video_F2S_out_blankCnt_next : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL user_sof                         : std_logic;  -- ufix1
  SIGNAL user_eol                         : std_logic;  -- ufix1
  SIGNAL enable_adapter_buffer            : std_logic;  -- ufix1
  SIGNAL hp_fifo_reset                    : std_logic;  -- ufix1
  SIGNAL hp_fifo_push                     : std_logic;  -- ufix1
  SIGNAL user_data                        : std_logic_vector(63 DOWNTO 0);  -- ufix64
  SIGNAL AXI4_Stream_Video_Master_TDATA_tmp : std_logic_vector(63 DOWNTO 0);  -- ufix64
  SIGNAL fifo_empty_data                  : std_logic;  -- ufix1

BEGIN
  u_gaussianF_ip_adapter_fifo_inst : gaussianF_ip_adapter_fifo
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              In_rsvd => user_pixel,  -- ufix64
              Push => hp_fifo_push,  -- ufix1
              Pop => control_valid,  -- ufix1
              reset_1 => hp_fifo_reset,  -- ufix1
              Out_rsvd => user_data,  -- ufix64
              AFull => hp_fifo_afull,  -- ufix1
              Num => hp_fifo_num  -- ufix11
              );

  u_gaussianF_ip_fifo_data_OUT_inst : gaussianF_ip_fifo_data_OUT
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              In_rsvd => user_data,  -- ufix64
              Push => fifo_push,  -- ufix1
              Pop => AXI4_Stream_Video_Master_TREADY,  -- ufix1
              Out_rsvd => AXI4_Stream_Video_Master_TDATA_tmp,  -- ufix64
              Empty => fifo_empty_data,  -- ufix1
              AFull => fifo_afull_data  -- ufix1
              );

  u_gaussianF_ip_fifo_eol_out_inst : gaussianF_ip_fifo_eol_out
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              In_rsvd => user_eol,  -- ufix1
              Push => fifo_push,  -- ufix1
              Pop => AXI4_Stream_Video_Master_TREADY,  -- ufix1
              Out_rsvd => AXI4_Stream_Video_Master_TLAST  -- ufix1
              );

  u_gaussianF_ip_fifo_sof_out_inst : gaussianF_ip_fifo_sof_out
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              In_rsvd => user_sof,  -- ufix1
              Push => fifo_push,  -- ufix1
              Pop => AXI4_Stream_Video_Master_TREADY,  -- ufix1
              Out_rsvd => AXI4_Stream_Video_Master_TUSER  -- ufix1
              );

  line_length <= to_unsigned(16#2F0#, 10);

  adapter_hPorch_unsigned <= unsigned(adapter_hPorch);

  const_three <= to_unsigned(16#3#, 2);

  fifo_push <= internal_ready AND control_valid;

  hp_fifo_not_full <=  NOT hp_fifo_afull;

  
  FIFO_not_empty <= '1' WHEN hp_fifo_num_unsigned >= resize(const_three, 11) ELSE
      '0';

  internal_ready <=  NOT fifo_afull_data;

  adapter_f2s_ready <= internal_ready AND FIFO_not_empty;

  hp_fifo_num_unsigned <= unsigned(hp_fifo_num);

  
  fifo_full_line <= '1' WHEN hp_fifo_num_unsigned >= resize(line_length, 11) ELSE
      '0';

  axi4_video_F2S_out_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        axi4_video_F2S_out_state_not_empty <= '0';
      ELSIF enb = '1' THEN
        axi4_video_F2S_out_state <= axi4_video_F2S_out_state_next;
        axi4_video_F2S_out_state_not_empty <= axi4_video_F2S_out_state_not_empty_next;
        axi4_video_F2S_out_hPos <= axi4_video_F2S_out_hPos_next;
        axi4_video_F2S_out_vPos <= axi4_video_F2S_out_vPos_next;
        axi4_video_F2S_out_valid <= axi4_video_F2S_out_valid_next;
        axi4_video_F2S_out_vStart <= axi4_video_F2S_out_vStart_next;
        axi4_video_F2S_out_hEnd <= axi4_video_F2S_out_hEnd_next;
        axi4_video_F2S_out_blankCnt <= axi4_video_F2S_out_blankCnt_next;
      END IF;
    END IF;
  END PROCESS axi4_video_F2S_out_process;

  axi4_video_F2S_out_output : PROCESS (adapter_active_frame, adapter_f2s_ready, adapter_hPorch_unsigned,
       adapter_partial_frame, axi4_video_F2S_out_blankCnt,
       axi4_video_F2S_out_hEnd, axi4_video_F2S_out_hPos,
       axi4_video_F2S_out_state, axi4_video_F2S_out_state_not_empty,
       axi4_video_F2S_out_vPos, axi4_video_F2S_out_vStart,
       axi4_video_F2S_out_valid, fifo_full_line)
    VARIABLE state_temp : unsigned(7 DOWNTO 0);
    VARIABLE hPos_temp : unsigned(9 DOWNTO 0);
    VARIABLE vPos_temp : unsigned(8 DOWNTO 0);
    VARIABLE valid_temp : std_logic;
    VARIABLE vStart_temp : std_logic;
    VARIABLE hEnd_temp : std_logic;
    VARIABLE blankCnt_temp : unsigned(9 DOWNTO 0);
  BEGIN
    state_temp := axi4_video_F2S_out_state;
    hPos_temp := axi4_video_F2S_out_hPos;
    vPos_temp := axi4_video_F2S_out_vPos;
    valid_temp := axi4_video_F2S_out_valid;
    vStart_temp := axi4_video_F2S_out_vStart;
    hEnd_temp := axi4_video_F2S_out_hEnd;
    blankCnt_temp := axi4_video_F2S_out_blankCnt;
    axi4_video_F2S_out_state_not_empty_next <= axi4_video_F2S_out_state_not_empty;
    IF ( NOT axi4_video_F2S_out_state_not_empty) = '1' THEN 
      state_temp := to_unsigned(16#00#, 8);
      axi4_video_F2S_out_state_not_empty_next <= '1';
      hPos_temp := to_unsigned(16#000#, 10);
      vPos_temp := to_unsigned(16#000#, 9);
      valid_temp := '0';
      vStart_temp := '0';
      hEnd_temp := '0';
      blankCnt_temp := adapter_hPorch_unsigned(9 DOWNTO 0);
    END IF;
    user_sof <= vStart_temp;
    user_eol <= hEnd_temp;
    control_valid <= valid_temp;
    CASE state_temp IS
      WHEN "00000000" =>
        hp_fifo_reset <= '0';
        vStart_temp := '0';
        hEnd_temp := '0';
        valid_temp := '0';
        enable_adapter_buffer <= '0';
        IF adapter_active_frame /= '0' THEN 
          state_temp := to_unsigned(16#01#, 8);
        END IF;
      WHEN "00000001" =>
        IF adapter_partial_frame /= '0' THEN 
          enable_adapter_buffer <= '0';
          state_temp := to_unsigned(16#00#, 8);
          valid_temp := '0';
          hp_fifo_reset <= '1';
        ELSE 
          enable_adapter_buffer <= '1';
          hp_fifo_reset <= '0';
          vStart_temp := '0';
          hEnd_temp := '0';
          valid_temp := '0';
          IF fifo_full_line /= '0' THEN 
            state_temp := to_unsigned(16#02#, 8);
            vPos_temp := to_unsigned(16#001#, 9);
          END IF;
        END IF;
      WHEN "00000010" =>
        IF adapter_partial_frame /= '0' THEN 
          state_temp := to_unsigned(16#00#, 8);
          valid_temp := '0';
          hp_fifo_reset <= '1';
          enable_adapter_buffer <= '0';
        ELSE 
          enable_adapter_buffer <= '1';
          hp_fifo_reset <= '0';
          blankCnt_temp := adapter_hPorch_unsigned(9 DOWNTO 0);
          hPos_temp := to_unsigned(16#001#, 10);
          IF adapter_f2s_ready /= '0' THEN 
            IF vPos_temp >= to_unsigned(16#001#, 9) THEN 
              valid_temp := '1';
              IF vPos_temp = to_unsigned(16#001#, 9) THEN 
                vStart_temp := '1';
              END IF;
            END IF;
            state_temp := to_unsigned(16#03#, 8);
          END IF;
        END IF;
      WHEN "00000011" =>
        IF adapter_partial_frame /= '0' THEN 
          state_temp := to_unsigned(16#00#, 8);
          valid_temp := '0';
          hp_fifo_reset <= '1';
          enable_adapter_buffer <= '0';
        ELSE 
          enable_adapter_buffer <= '1';
          hp_fifo_reset <= '0';
          vStart_temp := '0';
          IF adapter_f2s_ready /= '0' THEN 
            IF vPos_temp >= to_unsigned(16#001#, 9) THEN 
              valid_temp := '1';
            END IF;
            hPos_temp := hPos_temp + to_unsigned(16#001#, 10);
            IF resize(hPos_temp, 32) = to_unsigned(751, 32) THEN 
              state_temp := to_unsigned(16#04#, 8);
            END IF;
          ELSE 
            valid_temp := '0';
          END IF;
        END IF;
      WHEN "00000100" =>
        IF adapter_partial_frame /= '0' THEN 
          state_temp := to_unsigned(16#00#, 8);
          valid_temp := '0';
          hp_fifo_reset <= '1';
          enable_adapter_buffer <= '0';
        ELSE 
          enable_adapter_buffer <= '1';
          hp_fifo_reset <= '0';
          hEnd_temp := '1';
          valid_temp := '1';
          vPos_temp := vPos_temp + to_unsigned(16#001#, 9);
          state_temp := to_unsigned(16#05#, 8);
        END IF;
      WHEN "00000101" =>
        IF adapter_partial_frame /= '0' THEN 
          state_temp := to_unsigned(16#00#, 8);
          valid_temp := '0';
          hp_fifo_reset <= '1';
          enable_adapter_buffer <= '0';
        ELSE 
          enable_adapter_buffer <= hdlcoder_to_stdlogic( NOT (resize(vPos_temp, 32) = to_unsigned(481, 32)));
          hp_fifo_reset <= '0';
          hEnd_temp := '0';
          valid_temp := '0';
          IF blankCnt_temp > to_unsigned(16#000#, 10) THEN 
            blankCnt_temp := blankCnt_temp - to_unsigned(16#001#, 10);
          END IF;
          IF blankCnt_temp = to_unsigned(16#000#, 10) THEN 
            IF resize(vPos_temp, 32) = to_unsigned(481, 32) THEN 
              state_temp := to_unsigned(16#00#, 8);
            ELSE 
              state_temp := to_unsigned(16#02#, 8);
            END IF;
          END IF;
        END IF;
      WHEN OTHERS => 
        state_temp := to_unsigned(16#00#, 8);
        enable_adapter_buffer <= '0';
        hp_fifo_reset <= '0';
    END CASE;
    axi4_video_F2S_out_state_next <= state_temp;
    axi4_video_F2S_out_hPos_next <= hPos_temp;
    axi4_video_F2S_out_vPos_next <= vPos_temp;
    axi4_video_F2S_out_valid_next <= valid_temp;
    axi4_video_F2S_out_vStart_next <= vStart_temp;
    axi4_video_F2S_out_hEnd_next <= hEnd_temp;
    axi4_video_F2S_out_blankCnt_next <= blankCnt_temp;
  END PROCESS axi4_video_F2S_out_output;


  hp_fifo_push <= hp_fifo_not_full AND (enable_adapter_buffer AND user_valid);

  AXI4_Stream_Video_Master_TVALID <=  NOT fifo_empty_data;

  user_ready <= hp_fifo_not_full;

  AXI4_Stream_Video_Master_TDATA <= AXI4_Stream_Video_Master_TDATA_tmp;

END rtl;

