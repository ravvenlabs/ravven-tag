-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj1\hdlsrc\gaussianFilter\gaussianF_ip_src_NeighborhoodCreator_3x3.vhd
-- Created: 2024-06-04 12:57:05
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: gaussianF_ip_src_NeighborhoodCreator_3x3
-- Source Path: NeighborhoodCreator_3x3
-- Hierarchy Level: 3
-- Model version: 8.37
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.gaussianF_ip_src_gaussianFilter_pkg.ALL;

ENTITY gaussianF_ip_src_NeighborhoodCreator_3x3 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        sample                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        valid                             :   IN    std_logic;
        isLastSample                      :   IN    std_logic;
        neighborhood_0                    :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_1                    :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_2                    :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_3                    :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_4                    :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_5                    :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_6                    :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_7                    :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        neighborhood_8                    :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
        );
END gaussianF_ip_src_NeighborhoodCreator_3x3;


ARCHITECTURE rtl OF gaussianF_ip_src_NeighborhoodCreator_3x3 IS

  -- Component Declarations
  COMPONENT gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout                            :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_row3_col2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          sample_in                       :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          onEndVals_in                    :   IN    std_logic;
          valid                           :   IN    std_logic;
          isLastSample                    :   IN    std_logic;
          sample                          :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
          onEndVals                       :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_row2_linebuffer
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          sample_in                       :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          onEndVals_in                    :   IN    std_logic;
          valid                           :   IN    std_logic;
          isLastSample                    :   IN    std_logic;
          sample                          :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
          onEndVals                       :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : gaussianF_ip_src_SimpleDualPortRAM_generic
    USE ENTITY work.gaussianF_ip_src_SimpleDualPortRAM_generic(rtl);

  FOR ALL : gaussianF_ip_src_row3_col2
    USE ENTITY work.gaussianF_ip_src_row3_col2(rtl);

  FOR ALL : gaussianF_ip_src_row2_linebuffer
    USE ENTITY work.gaussianF_ip_src_row2_linebuffer(rtl);

  -- Signals
  SIGNAL mergedInput                      : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL mergedDelay_regin                : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL mergedDelay_waddr                : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL mergedDelay_wrenb                : std_logic;  -- ufix1
  SIGNAL mergedDelay_raddr                : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL mergedDelay_regout               : std_logic_vector(16 DOWNTO 0);  -- ufix17
  SIGNAL mergedDelay_regout_unsigned      : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL mergedOutput                     : unsigned(16 DOWNTO 0);  -- ufix17
  SIGNAL slicedInput                      : std_logic;  -- ufix1
  SIGNAL isLastSample_1                   : std_logic;
  SIGNAL slicedInput_1                    : std_logic;  -- ufix1
  SIGNAL valid_1                          : std_logic;
  SIGNAL slicedInput_2                    : std_logic;  -- ufix1
  SIGNAL isLastSample_2                   : std_logic;
  SIGNAL sample_1                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL onEndVals                        : std_logic;
  SIGNAL slicedInput_3                    : std_logic;  -- ufix1
  SIGNAL valid_2                          : std_logic;
  SIGNAL slicedInput_4                    : std_logic;  -- ufix1
  SIGNAL isLastSample_3                   : std_logic;
  SIGNAL sample_2                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL onEndVals_1                      : std_logic;
  SIGNAL slicedInput_5                    : std_logic;  -- ufix1
  SIGNAL valid_3                          : std_logic;
  SIGNAL slicedInput_6                    : std_logic;  -- ufix1
  SIGNAL isLastSample_4                   : std_logic;
  SIGNAL sample_3                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL onEndVals_2                      : std_logic;
  SIGNAL slicedInput_7                    : std_logic;  -- ufix1
  SIGNAL valid_4                          : std_logic;
  SIGNAL slicedInput_8                    : std_logic;  -- ufix1
  SIGNAL isLastSample_5                   : std_logic;
  SIGNAL sample_4                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL onEndVals_3                      : std_logic;
  SIGNAL slicedInput_9                    : std_logic;  -- ufix1
  SIGNAL valid_5                          : std_logic;
  SIGNAL slicedInput_10                   : std_logic;  -- ufix1
  SIGNAL isLastSample_6                   : std_logic;
  SIGNAL sample_5                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL onEndVals_4                      : std_logic;
  SIGNAL slicedInput_11                   : std_logic;  -- ufix1
  SIGNAL valid_6                          : std_logic;
  SIGNAL slicedInput_12                   : std_logic;  -- ufix1
  SIGNAL isLastSample_7                   : std_logic;
  SIGNAL sample_6                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL onEndVals_5                      : std_logic;
  SIGNAL slicedInput_13                   : std_logic;  -- ufix1
  SIGNAL valid_7                          : std_logic;
  SIGNAL slicedInput_14                   : std_logic;  -- ufix1
  SIGNAL isLastSample_8                   : std_logic;
  SIGNAL sample_7                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL onEndVals_6                      : std_logic;
  SIGNAL slicedInput_15                   : std_logic;  -- ufix1
  SIGNAL valid_8                          : std_logic;
  SIGNAL slicedInput_16                   : std_logic;  -- ufix1
  SIGNAL isLastSample_9                   : std_logic;
  SIGNAL onEndValsdeadOut                 : std_logic;
  SIGNAL max_neighborhood_col1            : vector_of_std_logic_vector32(0 TO 2);  -- ufix32 [3]
  SIGNAL max_neighborhood_col2            : vector_of_std_logic_vector32(0 TO 2);  -- ufix32 [3]
  SIGNAL max_neighborhood_col3            : vector_of_std_logic_vector32(0 TO 2);  -- ufix32 [3]
  SIGNAL max_neighborhood                 : matrix_of_std_logic_vector32(0 TO 2, 0 TO 2);  -- ufix32 [3x3]

BEGIN
  u_ShiftRegisterRAM : gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 6,
                 DataWidth => 17
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(mergedDelay_regin),
              wr_addr => std_logic_vector(mergedDelay_waddr),
              wr_en => mergedDelay_wrenb,  -- ufix1
              rd_addr => std_logic_vector(mergedDelay_raddr),
              dout => mergedDelay_regout
              );

  u_row3_col2 : gaussianF_ip_src_row3_col2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              sample_in => sample,  -- single
              onEndVals_in => isLastSample_1,
              valid => valid_1,
              isLastSample => isLastSample_2,
              sample => sample_1,  -- single
              onEndVals => onEndVals
              );

  u_row3_col1 : gaussianF_ip_src_row3_col2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              sample_in => sample_1,  -- single
              onEndVals_in => onEndVals,
              valid => valid_2,
              isLastSample => isLastSample_3,
              sample => sample_2,  -- single
              onEndVals => onEndVals_1
              );

  u_row2_linebuffer : gaussianF_ip_src_row2_linebuffer
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              sample_in => sample_2,  -- single
              onEndVals_in => onEndVals_1,
              valid => valid_3,
              isLastSample => isLastSample_4,
              sample => sample_3,  -- single
              onEndVals => onEndVals_2
              );

  u_row2_col2 : gaussianF_ip_src_row3_col2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              sample_in => sample_3,  -- single
              onEndVals_in => onEndVals_2,
              valid => valid_4,
              isLastSample => isLastSample_5,
              sample => sample_4,  -- single
              onEndVals => onEndVals_3
              );

  u_row2_col1 : gaussianF_ip_src_row3_col2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              sample_in => sample_4,  -- single
              onEndVals_in => onEndVals_3,
              valid => valid_5,
              isLastSample => isLastSample_6,
              sample => sample_5,  -- single
              onEndVals => onEndVals_4
              );

  u_row1_linebuffer : gaussianF_ip_src_row2_linebuffer
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              sample_in => sample_5,  -- single
              onEndVals_in => onEndVals_4,
              valid => valid_6,
              isLastSample => isLastSample_7,
              sample => sample_6,  -- single
              onEndVals => onEndVals_5
              );

  u_row1_col2 : gaussianF_ip_src_row3_col2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              sample_in => sample_6,  -- single
              onEndVals_in => onEndVals_5,
              valid => valid_7,
              isLastSample => isLastSample_8,
              sample => sample_7,  -- single
              onEndVals => onEndVals_6
              );

  u_row1_col1 : gaussianF_ip_src_row3_col2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              sample_in => sample_7,  -- single
              onEndVals_in => onEndVals_6,
              valid => valid_8,
              isLastSample => isLastSample_9,
              sample => max_neighborhood_col1(0),  -- single
              onEndVals => onEndValsdeadOut
              );

  mergedInput <= unsigned'(isLastSample & valid & isLastSample & valid & isLastSample & valid & isLastSample & valid & isLastSample & valid & isLastSample & valid & isLastSample & valid & isLastSample & valid & isLastSample);

  -- Input register for RAM-based shift register mergedDelay
  mergedDelay_reginc_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_regin <= to_unsigned(16#00000#, 17);
      ELSIF enb = '1' THEN
        mergedDelay_regin <= mergedInput;
      END IF;
    END IF;
  END PROCESS mergedDelay_reginc_process;


  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 48
  -- Write address counter for RAM-based shift register mergedDelay
  mergedDelay_wr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_waddr <= to_unsigned(16#00#, 6);
      ELSIF enb = '1' THEN
        IF mergedDelay_waddr >= to_unsigned(16#30#, 6) THEN 
          mergedDelay_waddr <= to_unsigned(16#00#, 6);
        ELSE 
          mergedDelay_waddr <= mergedDelay_waddr + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_wr_process;


  mergedDelay_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 48
  -- Read address counter for RAM-based shift register mergedDelay
  mergedDelay_rd_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_raddr <= to_unsigned(16#01#, 6);
      ELSIF enb = '1' THEN
        IF mergedDelay_raddr >= to_unsigned(16#30#, 6) THEN 
          mergedDelay_raddr <= to_unsigned(16#00#, 6);
        ELSE 
          mergedDelay_raddr <= mergedDelay_raddr + to_unsigned(16#01#, 6);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_rd_process;


  mergedDelay_regout_unsigned <= unsigned(mergedDelay_regout);

  -- Output register for RAM-based shift register mergedDelay
  mergedDelay_regoutc_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedOutput <= to_unsigned(16#00000#, 17);
      ELSIF enb = '1' THEN
        mergedOutput <= mergedDelay_regout_unsigned;
      END IF;
    END IF;
  END PROCESS mergedDelay_regoutc_process;


  slicedInput <= mergedOutput(16);

  isLastSample_1 <= slicedInput;

  slicedInput_1 <= mergedOutput(15);

  valid_1 <= slicedInput_1;

  slicedInput_2 <= mergedOutput(14);

  isLastSample_2 <= slicedInput_2;

  slicedInput_3 <= mergedOutput(13);

  valid_2 <= slicedInput_3;

  slicedInput_4 <= mergedOutput(12);

  isLastSample_3 <= slicedInput_4;

  slicedInput_5 <= mergedOutput(11);

  valid_3 <= slicedInput_5;

  slicedInput_6 <= mergedOutput(10);

  isLastSample_4 <= slicedInput_6;

  slicedInput_7 <= mergedOutput(9);

  valid_4 <= slicedInput_7;

  slicedInput_8 <= mergedOutput(8);

  isLastSample_5 <= slicedInput_8;

  slicedInput_9 <= mergedOutput(7);

  valid_5 <= slicedInput_9;

  slicedInput_10 <= mergedOutput(6);

  isLastSample_6 <= slicedInput_10;

  slicedInput_11 <= mergedOutput(5);

  valid_6 <= slicedInput_11;

  slicedInput_12 <= mergedOutput(4);

  isLastSample_7 <= slicedInput_12;

  slicedInput_13 <= mergedOutput(3);

  valid_7 <= slicedInput_13;

  slicedInput_14 <= mergedOutput(2);

  isLastSample_8 <= slicedInput_14;

  slicedInput_15 <= mergedOutput(1);

  valid_8 <= slicedInput_15;

  slicedInput_16 <= mergedOutput(0);

  isLastSample_9 <= slicedInput_16;

  max_neighborhood_col1(1) <= sample_5;
  max_neighborhood_col1(2) <= sample_2;

  max_neighborhood_col2(0) <= sample_7;
  max_neighborhood_col2(1) <= sample_4;
  max_neighborhood_col2(2) <= sample_1;

  max_neighborhood_col3(0) <= sample_6;
  max_neighborhood_col3(1) <= sample_3;
  max_neighborhood_col3(2) <= sample;

  max_neighborhood_gen: FOR idx IN 0 TO 2 GENERATE
    max_neighborhood(idx, 0) <= max_neighborhood_col1(idx);
  END GENERATE;
  max_neighborhood_gen1: FOR idx IN 0 TO 2 GENERATE
    max_neighborhood(idx, 1) <= max_neighborhood_col2(idx);
  END GENERATE;
  max_neighborhood_gen2: FOR idx IN 0 TO 2 GENERATE
    max_neighborhood(idx, 2) <= max_neighborhood_col3(idx);
  END GENERATE;

  neighborhood_0 <= max_neighborhood(0, 0);

  neighborhood_1 <= max_neighborhood(1, 0);

  neighborhood_2 <= max_neighborhood(2, 0);

  neighborhood_3 <= max_neighborhood(0, 1);

  neighborhood_4 <= max_neighborhood(1, 1);

  neighborhood_5 <= max_neighborhood(2, 1);

  neighborhood_6 <= max_neighborhood(0, 2);

  neighborhood_7 <= max_neighborhood(1, 2);

  neighborhood_8 <= max_neighborhood(2, 2);

END rtl;

