-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj1\hdlsrc\gaussianFilter\gaussianF_ip_src_gaussianKernel.vhd
-- Created: 2024-06-19 09:54:13
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: gaussianF_ip_src_gaussianKernel
-- Source Path: gaussianFilter/gaussianFilter/frameBasedGaussianFilter/gaussianKernel
-- Hierarchy Level: 2
-- Model version: 8.39
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.gaussianF_ip_src_gaussianFilter_pkg.ALL;

ENTITY gaussianF_ip_src_gaussianKernel IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        in_0                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_1                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_2                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_3                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_4                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_5                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_6                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_7                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_8                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_0                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_1                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_2                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_3                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_4                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_5                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_6                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_7                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        data_8                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        in_valid                          :   IN    std_logic;
        e                                 :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        e_valid                           :   OUT   std_logic
        );
END gaussianF_ip_src_gaussianKernel;


ARCHITECTURE rtl OF gaussianF_ip_src_gaussianKernel IS

  -- Component Declarations
  COMPONENT gaussianF_ip_src_nfp_mul_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_nfp_add_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          dout                            :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : gaussianF_ip_src_nfp_mul_single
    USE ENTITY work.gaussianF_ip_src_nfp_mul_single(rtl);

  FOR ALL : gaussianF_ip_src_nfp_add_single
    USE ENTITY work.gaussianF_ip_src_nfp_add_single(rtl);

  FOR ALL : gaussianF_ip_src_SimpleDualPortRAM_generic
    USE ENTITY work.gaussianF_ip_src_SimpleDualPortRAM_generic(rtl);

  -- Signals
  SIGNAL in_rsvd                          : matrix_of_std_logic_vector32(0 TO 2, 0 TO 2);  -- ufix32 [3x3]
  SIGNAL c1_in                            : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL data                             : matrix_of_std_logic_vector32(0 TO 2, 0 TO 2);  -- ufix32 [3x3]
  SIGNAL c1_data                          : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL c1_temp                          : vector_of_std_logic_vector32(0 TO 8);  -- ufix32 [9]
  SIGNAL temp                             : matrix_of_std_logic_vector32(0 TO 2, 0 TO 2);  -- ufix32 [3x3]
  SIGNAL In_1_0_2                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL In_1_1_2                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL In_1_2_2                         : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL sum_op_stage1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL mergedDelay_waddr                : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL mergedDelay_wrenb                : std_logic;  -- ufix1
  SIGNAL mergedDelay_raddr                : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL mergedOutput                     : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL slicedInput                      : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL In_1_2_2_1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Out_1_2                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Out_1_2_1                        : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL mergedInput                      : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL mergedDelay_regin                : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL mergedDelay_regout               : std_logic_vector(127 DOWNTO 0);  -- ufix128
  SIGNAL mergedDelay_regout_unsigned      : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL sum_op_stage1_1                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_1                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL In_1_0_2_1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Out_1_0                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL sum_op_stage1_2                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_2                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL In_1_1_2_1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Out_1_1                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL sum_op_stage1_3                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL slicedInput_3                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL In_1_2                           : std_logic_vector(31 DOWNTO 0);  -- ufix32

BEGIN
  u_nfp_add_comp : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => temp(0, 2),  -- single
              nfp_in2 => temp(1, 2),  -- single
              nfp_out => sum_op_stage1  -- single
              );

  u_nfp_add_comp_1 : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => sum_op_stage1,  -- single
              nfp_in2 => In_1_2_2_1,  -- single
              nfp_out => Out_1_2  -- single
              );

  u_ShiftRegisterRAM : gaussianF_ip_src_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 3,
                 DataWidth => 128
                 )
    PORT MAP( clk => clk,
              enb => enb,
              wr_din => std_logic_vector(mergedDelay_regin),
              wr_addr => std_logic_vector(mergedDelay_waddr),
              wr_en => mergedDelay_wrenb,  -- ufix1
              rd_addr => std_logic_vector(mergedDelay_raddr),
              dout => mergedDelay_regout
              );

  u_nfp_add_comp_2 : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => temp(0, 0),  -- single
              nfp_in2 => temp(1, 0),  -- single
              nfp_out => sum_op_stage1_1  -- single
              );

  u_nfp_add_comp_3 : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => sum_op_stage1_1,  -- single
              nfp_in2 => In_1_0_2_1,  -- single
              nfp_out => Out_1_0  -- single
              );

  u_nfp_add_comp_4 : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => temp(0, 1),  -- single
              nfp_in2 => temp(1, 1),  -- single
              nfp_out => sum_op_stage1_2  -- single
              );

  u_nfp_add_comp_5 : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => sum_op_stage1_2,  -- single
              nfp_in2 => In_1_1_2_1,  -- single
              nfp_out => Out_1_1  -- single
              );

  u_nfp_add_comp_6 : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => Out_1_0,  -- single
              nfp_in2 => Out_1_1,  -- single
              nfp_out => sum_op_stage1_3  -- single
              );

  u_nfp_add_comp_7 : gaussianF_ip_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => sum_op_stage1_3,  -- single
              nfp_in2 => In_1_2,  -- single
              nfp_out => e  -- single
              );

  in_rsvd(0, 0) <= in_0;
  in_rsvd(1, 0) <= in_1;
  in_rsvd(2, 0) <= in_2;
  in_rsvd(0, 1) <= in_3;
  in_rsvd(1, 1) <= in_4;
  in_rsvd(2, 1) <= in_5;
  in_rsvd(0, 2) <= in_6;
  in_rsvd(1, 2) <= in_7;
  in_rsvd(2, 2) <= in_8;

  c1_in_gen1: FOR d1 IN 0 TO 2 GENERATE
    c1_in_gen: FOR d0 IN 0 TO 2 GENERATE
      c1_in(d0 + (d1 * 3)) <= in_rsvd(d0, d1);
    END GENERATE;
  END GENERATE;

  data(0, 0) <= data_0;
  data(1, 0) <= data_1;
  data(2, 0) <= data_2;
  data(0, 1) <= data_3;
  data(1, 1) <= data_4;
  data(2, 1) <= data_5;
  data(0, 2) <= data_6;
  data(1, 2) <= data_7;
  data(2, 2) <= data_8;

  c1_data_gen1: FOR d1 IN 0 TO 2 GENERATE
    c1_data_gen: FOR d0 IN 0 TO 2 GENERATE
      c1_data(d0 + (d1 * 3)) <= data(d0, d1);
    END GENERATE;
  END GENERATE;

  u_nfp_mul_comp_gen: FOR k IN 0 TO 8 GENERATE
    u_nfp_mul_comp : gaussianF_ip_src_nfp_mul_single
      PORT MAP( clk => clk,
                reset => reset,
                enb => enb,
                nfp_in1 => c1_in(k),  -- ufix32
                nfp_in2 => c1_data(k),  -- ufix32
                nfp_out => c1_temp(k)  -- ufix32
                );
  END GENERATE;

  temp_gen1: FOR d1 IN 0 TO 2 GENERATE
    temp_gen: FOR d0 IN 0 TO 2 GENERATE
      temp(d0, d1) <= c1_temp(d0 + (d1 * 3));
    END GENERATE;
  END GENERATE;

  In_1_0_2 <= unsigned(temp(2, 0));

  In_1_1_2 <= unsigned(temp(2, 1));

  In_1_2_2 <= unsigned(temp(2, 2));

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 3
  -- Write address counter for RAM-based shift register mergedDelay
  mergedDelay_wr_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_waddr <= to_unsigned(16#0#, 3);
      ELSIF enb = '1' THEN
        IF mergedDelay_waddr >= to_unsigned(16#3#, 3) THEN 
          mergedDelay_waddr <= to_unsigned(16#0#, 3);
        ELSE 
          mergedDelay_waddr <= mergedDelay_waddr + to_unsigned(16#1#, 3);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_wr_process;


  mergedDelay_wrenb <= '1';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 3
  -- Read address counter for RAM-based shift register mergedDelay
  mergedDelay_rd_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_raddr <= to_unsigned(16#1#, 3);
      ELSIF enb = '1' THEN
        IF mergedDelay_raddr >= to_unsigned(16#3#, 3) THEN 
          mergedDelay_raddr <= to_unsigned(16#0#, 3);
        ELSE 
          mergedDelay_raddr <= mergedDelay_raddr + to_unsigned(16#1#, 3);
        END IF;
      END IF;
    END IF;
  END PROCESS mergedDelay_rd_process;


  slicedInput <= mergedOutput(63 DOWNTO 32);

  In_1_2_2_1 <= std_logic_vector(resize(slicedInput, 32));

  Out_1_2_1 <= unsigned(Out_1_2);

  mergedInput <= In_1_0_2 & In_1_1_2 & In_1_2_2 & Out_1_2_1;

  -- Input register for RAM-based shift register mergedDelay
  mergedDelay_reginc_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedDelay_regin <= to_unsigned(0, 128);
      ELSIF enb = '1' THEN
        mergedDelay_regin <= mergedInput;
      END IF;
    END IF;
  END PROCESS mergedDelay_reginc_process;


  mergedDelay_regout_unsigned <= unsigned(mergedDelay_regout);

  -- Output register for RAM-based shift register mergedDelay
  mergedDelay_regoutc_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mergedOutput <= to_unsigned(0, 128);
      ELSIF enb = '1' THEN
        mergedOutput <= mergedDelay_regout_unsigned;
      END IF;
    END IF;
  END PROCESS mergedDelay_regoutc_process;


  slicedInput_1 <= mergedOutput(127 DOWNTO 96);

  In_1_0_2_1 <= std_logic_vector(resize(slicedInput_1, 32));

  slicedInput_2 <= mergedOutput(95 DOWNTO 64);

  In_1_1_2_1 <= std_logic_vector(resize(slicedInput_2, 32));

  slicedInput_3 <= mergedOutput(31 DOWNTO 0);

  In_1_2 <= std_logic_vector(resize(slicedInput_3, 32));

  e_valid <= in_valid;

END rtl;

