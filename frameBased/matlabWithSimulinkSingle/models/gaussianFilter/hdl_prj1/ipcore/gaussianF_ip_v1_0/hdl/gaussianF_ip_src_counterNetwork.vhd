-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj1\hdlsrc\gaussianFilter\gaussianF_ip_src_counterNetwork.vhd
-- Created: 2024-06-04 12:57:05
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: gaussianF_ip_src_counterNetwork
-- Source Path: counterNetwork
-- Hierarchy Level: 3
-- Model version: 8.37
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY gaussianF_ip_src_counterNetwork IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        validNext                         :   IN    std_logic;
        valid                             :   IN    std_logic;
        isLastSample                      :   OUT   std_logic;
        isEndOfLine                       :   OUT   std_logic;
        rowCtr                            :   OUT   std_logic_vector(8 DOWNTO 0);  -- ufix9
        colCtr                            :   OUT   std_logic_vector(9 DOWNTO 0);  -- ufix10
        pxlCtr                            :   OUT   std_logic_vector(18 DOWNTO 0);  -- ufix19
        isEndOfLineEnd                    :   OUT   std_logic;
        rowCtrEnd                         :   OUT   std_logic_vector(8 DOWNTO 0);  -- ufix9
        colCtrEnd                         :   OUT   std_logic_vector(9 DOWNTO 0);  -- ufix10
        pxlCtrEnd                         :   OUT   std_logic_vector(18 DOWNTO 0)  -- ufix19
        );
END gaussianF_ip_src_counterNetwork;


ARCHITECTURE rtl OF gaussianF_ip_src_counterNetwork IS

  -- Signals
  SIGNAL pxlCtr_tmp                       : unsigned(18 DOWNTO 0);  -- ufix19
  SIGNAL pxlCtrIsMax_1                    : std_logic;
  SIGNAL isLastSample_1                   : std_logic;
  SIGNAL colCtr_tmp                       : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL colCtrIsMax_1                    : std_logic;
  SIGNAL enbRowCtr_1                      : std_logic;
  SIGNAL rowCtr_tmp                       : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL pxlCtrEnd_loadValue_1            : unsigned(18 DOWNTO 0);  -- ufix19
  SIGNAL onEndValues                      : std_logic;
  SIGNAL pxlCtrEnd_tmp                    : unsigned(18 DOWNTO 0);  -- ufix19
  SIGNAL colCtrEnd_tmp                    : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL isEndOfLineEnd_1                 : std_logic;
  SIGNAL rowCtrEnd_tmp                    : unsigned(8 DOWNTO 0);  -- ufix9

BEGIN
  -- Count limited, Unsigned Counter
  --  initial value   = 360960
  --  step value      = 1
  --  count to value  = 360960
  pxlCtr1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        pxlCtr_tmp <= to_unsigned(16#58200#, 19);
      ELSIF enb = '1' THEN
        IF validNext = '1' THEN 
          IF pxlCtr_tmp >= to_unsigned(16#58200#, 19) THEN 
            pxlCtr_tmp <= to_unsigned(16#00001#, 19);
          ELSE 
            pxlCtr_tmp <= pxlCtr_tmp + to_unsigned(16#00001#, 19);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS pxlCtr1_process;


  
  pxlCtrIsMax_1 <= '1' WHEN pxlCtr_tmp = to_unsigned(16#58200#, 19) ELSE
      '0';

  isLastSample_1 <= pxlCtrIsMax_1 AND valid;

  -- Count limited, Unsigned Counter
  --  initial value   = 752
  --  step value      = 1
  --  count to value  = 752
  colCtr1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        colCtr_tmp <= to_unsigned(16#2F0#, 10);
      ELSIF enb = '1' THEN
        IF validNext = '1' THEN 
          IF colCtr_tmp >= to_unsigned(16#2F0#, 10) THEN 
            colCtr_tmp <= to_unsigned(16#001#, 10);
          ELSE 
            colCtr_tmp <= colCtr_tmp + to_unsigned(16#001#, 10);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS colCtr1_process;


  
  colCtrIsMax_1 <= '1' WHEN colCtr_tmp = to_unsigned(16#2F0#, 10) ELSE
      '0';

  isEndOfLine <= colCtrIsMax_1 AND valid;

  enbRowCtr_1 <= colCtrIsMax_1 AND validNext;

  -- Count limited, Unsigned Counter
  --  initial value   = 480
  --  step value      = 1
  --  count to value  = 480
  rowCtr1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        rowCtr_tmp <= to_unsigned(16#1E0#, 9);
      ELSIF enb = '1' THEN
        IF enbRowCtr_1 = '1' THEN 
          IF rowCtr_tmp >= to_unsigned(16#1E0#, 9) THEN 
            rowCtr_tmp <= to_unsigned(16#001#, 9);
          ELSE 
            rowCtr_tmp <= rowCtr_tmp + to_unsigned(16#001#, 9);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS rowCtr1_process;


  rowCtr <= std_logic_vector(rowCtr_tmp);

  colCtr <= std_logic_vector(colCtr_tmp);

  pxlCtr <= std_logic_vector(pxlCtr_tmp);

  pxlCtrEnd_loadValue_1 <= to_unsigned(16#00001#, 19);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1507
  pxlCtrEnd1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        pxlCtrEnd_tmp <= to_unsigned(16#00000#, 19);
      ELSIF enb = '1' THEN
        IF isLastSample_1 = '1' THEN 
          pxlCtrEnd_tmp <= pxlCtrEnd_loadValue_1;
        ELSIF onEndValues = '1' THEN 
          IF pxlCtrEnd_tmp >= to_unsigned(16#005E3#, 19) THEN 
            pxlCtrEnd_tmp <= to_unsigned(16#00000#, 19);
          ELSE 
            pxlCtrEnd_tmp <= pxlCtrEnd_tmp + to_unsigned(16#00001#, 19);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS pxlCtrEnd1_process;


  
  onEndValues <= '1' WHEN pxlCtrEnd_tmp /= to_unsigned(16#00000#, 19) ELSE
      '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 752
  colCtrEnd1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        colCtrEnd_tmp <= to_unsigned(16#001#, 10);
      ELSIF enb = '1' THEN
        IF isLastSample_1 = '1' THEN 
          colCtrEnd_tmp <= to_unsigned(16#001#, 10);
        ELSIF onEndValues = '1' THEN 
          IF colCtrEnd_tmp >= to_unsigned(16#2F0#, 10) THEN 
            colCtrEnd_tmp <= to_unsigned(16#001#, 10);
          ELSE 
            colCtrEnd_tmp <= colCtrEnd_tmp + to_unsigned(16#001#, 10);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS colCtrEnd1_process;


  
  isEndOfLineEnd_1 <= '1' WHEN colCtrEnd_tmp = to_unsigned(16#2F0#, 10) ELSE
      '0';

  -- Count limited, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  --  count to value  = 480
  rowCtrEnd1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        rowCtrEnd_tmp <= to_unsigned(16#001#, 9);
      ELSIF enb = '1' THEN
        IF isLastSample_1 = '1' THEN 
          rowCtrEnd_tmp <= to_unsigned(16#001#, 9);
        ELSIF isEndOfLineEnd_1 = '1' THEN 
          IF rowCtrEnd_tmp >= to_unsigned(16#1E0#, 9) THEN 
            rowCtrEnd_tmp <= to_unsigned(16#001#, 9);
          ELSE 
            rowCtrEnd_tmp <= rowCtrEnd_tmp + to_unsigned(16#001#, 9);
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS rowCtrEnd1_process;


  rowCtrEnd <= std_logic_vector(rowCtrEnd_tmp);

  colCtrEnd <= std_logic_vector(colCtrEnd_tmp);

  pxlCtrEnd <= std_logic_vector(pxlCtrEnd_tmp);

  isLastSample <= isLastSample_1;

  isEndOfLineEnd <= isEndOfLineEnd_1;

END rtl;

